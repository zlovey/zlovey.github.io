<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/cat_32.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/cat_16.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="排序 平均时间复杂度 最差时间复杂度 最优时间复杂度 空间复杂度 稳定性     交换排序 冒泡排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 稳定   插入排序 插入排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 稳定   选择排序 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定   插入排序 希尔排序 $">
<meta property="og:type" content="article">
<meta property="og:title" content="排序">
<meta property="og:url" content="http://yoursite.com/2020/06/02/算法整理/排序/index.html">
<meta property="og:site_name" content="Garden">
<meta property="og:description" content="排序 平均时间复杂度 最差时间复杂度 最优时间复杂度 空间复杂度 稳定性     交换排序 冒泡排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 稳定   插入排序 插入排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 稳定   选择排序 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定   插入排序 希尔排序 $">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2020/06/02/算法整理/排序/F:/blog/source/_posts/算法整理/排序/冒泡排序.gif">
<meta property="og:image" content="http://yoursite.com/2020/06/02/算法整理/排序/F:/blog/source/_posts/算法整理/排序/快速排序.gif">
<meta property="og:image" content="http://yoursite.com/2020/06/02/算法整理/排序/F:/blog/source/_posts/算法整理/排序/插入排序.gif">
<meta property="og:image" content="http://yoursite.com/2020/06/02/算法整理/排序/F:/blog/source/_posts/算法整理/排序/希尔排序.gif">
<meta property="og:image" content="http://yoursite.com/2020/06/02/算法整理/排序/F:/blog/source/_posts/算法整理/排序/选择排序.gif">
<meta property="og:image" content="http://yoursite.com/2020/06/02/算法整理/排序/F:/blog/source/_posts/算法整理/排序/堆排序.gif">
<meta property="og:image" content="http://yoursite.com/2020/06/02/算法整理/排序/F:/blog/source/_posts/算法整理/排序/归并排序.gif">
<meta property="og:image" content="http://yoursite.com/2020/06/02/算法整理/排序/F:/blog/source/_posts/算法整理/排序/计数排序.gif">
<meta property="og:image" content="http://yoursite.com/2020/06/02/算法整理/排序/F:/blog/source/_posts/算法整理/排序/计数-优化.jpg.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/算法整理/排序/F:/blog/source/_posts/算法整理/排序/桶排序.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/算法整理/排序/F:/blog/source/_posts/算法整理/排序/基数排序.gif">
<meta property="og:updated_time" content="2020-06-12T13:04:43.927Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="排序">
<meta name="twitter:description" content="排序 平均时间复杂度 最差时间复杂度 最优时间复杂度 空间复杂度 稳定性     交换排序 冒泡排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 稳定   插入排序 插入排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 稳定   选择排序 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定   插入排序 希尔排序 $">
<meta name="twitter:image" content="http://yoursite.com/2020/06/02/算法整理/排序/F:/blog/source/_posts/算法整理/排序/冒泡排序.gif">






  <link rel="canonical" href="http://yoursite.com/2020/06/02/算法整理/排序/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>排序 | Garden</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/zlovey"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Garden</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">
    <a href="/schedule/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />日程表</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/02/算法整理/排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lavi">
      <meta itemprop="description" content="进化ing">
      <meta itemprop="image" content="/images/headimg/14.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Garden">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">排序
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-06-02 21:19:23" itemprop="dateCreated datePublished" datetime="2020-06-02T21:19:23+08:00">2020-06-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-06-12 21:04:43" itemprop="dateModified" datetime="2020-06-12T21:04:43+08:00">2020-06-12</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法整理/" itemprop="url" rel="index"><span itemprop="name">算法整理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <table>
<thead>
<tr>
<th></th>
<th style="text-align:left">排序</th>
<th style="text-align:center">平均时间复杂度</th>
<th style="text-align:center">最差时间复杂度</th>
<th style="text-align:center">最优时间复杂度</th>
<th style="text-align:center">空间复杂度</th>
<th style="text-align:center">稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>交换排序</td>
<td style="text-align:left">冒泡排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td style="text-align:left">插入排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td style="text-align:left">选择排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td style="text-align:left">希尔排序</td>
<td style="text-align:center">$O(n^{1.3})$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td>交换排序</td>
<td style="text-align:left">快速排序</td>
<td style="text-align:center">$O(nlog_2n)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(nlog_2n)$</td>
<td style="text-align:center">$O(log_2n)$</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">归并排序</td>
<td style="text-align:center">$O(nlog_2n)$</td>
<td style="text-align:center">$O(nlog_2n)$</td>
<td style="text-align:center">$O(nlog_2n)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td style="text-align:left">堆排序</td>
<td style="text-align:center">$O(nlog_2n)$</td>
<td style="text-align:center">$O(nlog_2n)$</td>
<td style="text-align:center">$O(nlog_2n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">计数排序</td>
<td style="text-align:center">$O(n+k)$</td>
<td style="text-align:center">$O(n+k)$</td>
<td style="text-align:center">$O(n+k)$</td>
<td style="text-align:center">$O(n+k)$</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">桶排序</td>
<td style="text-align:center">$O(n+k)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(n+k)$</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">基数排序</td>
<td style="text-align:center">$O(n * k)$</td>
<td style="text-align:center">$O(n * k)$</td>
<td style="text-align:center">$O(n * k)$</td>
<td style="text-align:center">$O(r)$</td>
<td style="text-align:center">稳定</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>一共十个算法，按照分类的顺序对不同算法进行挨个介绍。</p>
<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个</li>
</ul>
<p><img src="/2020/06/02/算法整理/排序/F:/blog\source\_posts\算法整理\排序\冒泡排序.gif" alt="冒泡排序"></p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])</span><br><span class="line">                swap(arr[j],arr[j+<span class="number">1</span>]);</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag==<span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InverseBubbleSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(arr[j],arr[j<span class="number">-1</span>]);</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag==<span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度及稳定性"><a href="#复杂度及稳定性" class="headerlink" title="复杂度及稳定性"></a>复杂度及稳定性</h4><ul>
<li>平均复杂度<ul>
<li>$O(n^2)$ ：对长度为n的数组进行两层循环遍历</li>
</ul>
</li>
<li>最坏复杂度<ul>
<li>$O(n^2)$ ：对长度为n的数组进行两层循环遍历</li>
</ul>
</li>
<li>最优复杂度<ul>
<li>$O(n)$：数组本身就有顺序，不用进行交换，根据flag遍历一次即可</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>$O(1)$：不用额外的空间占用</li>
</ul>
</li>
<li>稳定性<ul>
<li>稳定：由于每次只在两个相邻的数之间进行比较，确定了顺序或者逆序之后，若满足要求则不会交换，若违背要求的则交换。因此是稳定性的算法。</li>
</ul>
</li>
</ul>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul>
<li>通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</li>
<li>快速排序使用<strong>分治法</strong>来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：<ul>
<li>从数列中挑出一个元素，称为 “基准”<code>pivot</code>；<ul>
<li>通过一趟排序将待排序表划分为独立的两部分：<code>L[1..k-1]</code>和<code>L[k+1...n]</code>，使得<code>L[1..k-1]</code>的所有元素都小于<code>pivot</code>，<code>[k+1...n]</code>的所有元素都大于或等于<code>pivot</code>，此时<code>pivot</code>已经放在其最终的位置L(k)。——一趟快排</li>
</ul>
</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
</li>
</ul>
<p><img src="/2020/06/02/算法整理/排序/F:/blog\source\_posts\算法整理\排序\快速排序.gif" alt="快速排序"></p>
<h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅算法结构</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(ELemType A[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pivotpos = Partition(A,low,high);</span><br><span class="line">        QuickSort(A,low,pivotpos<span class="number">-1</span>);</span><br><span class="line">        QuickSort(A,pivotpos+<span class="number">1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一趟快排</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(ELemType A[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ELemType pivot=A[low]; <span class="comment">//取low位置的值为枢轴</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 因为此处设置的基准数是最左边的数，所以需要让哨兵j先出动，这一点非常重要（</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; A[high]&gt;=pivot) --high;</span><br><span class="line">        A[low]=A[high];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; A[low]&lt;pivot) ++low;</span><br><span class="line">        A[high]=A[low];</span><br><span class="line">    &#125;</span><br><span class="line">    A[low]=pivot; <span class="comment">//枢轴值最后放在low位置处 此时low是大于等于high的</span></span><br><span class="line">    <span class="keyword">return</span> low;  <span class="comment">//返回枢轴的存放位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度及稳定性-1"><a href="#复杂度及稳定性-1" class="headerlink" title="复杂度及稳定性"></a>复杂度及稳定性</h4><ul>
<li>平均复杂度<ul>
<li>$O(nlog_2n)$ ：对每个枢轴值遍历整个数组，但对枢轴值的选取采取折半的方式进行</li>
</ul>
</li>
<li>最坏复杂度<ul>
<li>$O(n^2)$ ：对本就有序（正序或逆序）的数组，对每个枢轴值都遍历整个数组，不能进行折半优化</li>
</ul>
</li>
<li>最优复杂度<ul>
<li>$O(nlog_2n)$：理想情况下每次都对数组进行折半比较交换</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>$O(log_2n)$：由于快排涉及到递归操作，因此递归工作栈容量与递归调用的最大深度一致</li>
</ul>
</li>
<li>稳定性<ul>
<li>不稳定：由于遍历数组时采用左右两个方向进行操作，在交换的时候就会导致算法的不稳定。如：若右边区间存在两个关键字相同，且均小于基准值的记录，则在交换到左端区间时，相对位置就会发生变化。</li>
</ul>
</li>
<li><strong>快排是所有内部排序算法中平均性能最优的排序算法</strong></li>
</ul>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><ul>
<li>对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</li>
</ul>
<p><img src="/2020/06/02/算法整理/排序/F:/blog\source\_posts\算法整理\排序\插入排序.gif" alt="插入排序"></p>
<h4 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) <span class="comment">//将A[1]-A[n]插入到前面已排序的序列中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i]&lt;A[i<span class="number">-1</span>])<span class="comment">//若A[i]的值小于其前驱的值，需要将A[i]插入有序表</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cur=A[i]; <span class="comment">//复制为哨兵</span></span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;cur&lt;A[j];--j)<span class="comment">//从后往前开始查找插入的位置在</span></span><br><span class="line">                A[j+<span class="number">1</span>]=A[j];<span class="comment">//向后挪位置</span></span><br><span class="line">            A[j+<span class="number">1</span>]=cur;<span class="comment">//复制到应该插入的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度及稳定性-2"><a href="#复杂度及稳定性-2" class="headerlink" title="复杂度及稳定性"></a>复杂度及稳定性</h4><ul>
<li>平均复杂度<ul>
<li>$O(n^2)$ ：对每个值，遍历其前方的所有值，寻找合适的插入点</li>
</ul>
</li>
<li>最坏复杂度<ul>
<li>$O(n^2)$ ：在数组本身逆序的情况下，对每个元素都要移动到最前方</li>
</ul>
</li>
<li>最优复杂度<ul>
<li>$O(n )$：在数组本身顺序的情况下，每次只需要在大循环上进行一次比较，而不用进行元素的移动</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>$O(1)$：直接采用<code>in-place</code>的方法，在原数组上进行替换，应该不需要额外的</li>
</ul>
</li>
<li>稳定性<ul>
<li>稳定：对于每次插入元素时总是从后往前先比较再移动，所以是稳定的</li>
</ul>
</li>
<li><strong>适用于基本有序或者数据量不大的排序表</strong></li>
</ul>
<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><h4 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h4><ul>
<li>插入排序可以分为两部分操作：<ul>
<li>查找元素应该插入的位置</li>
<li>给插入位置腾出空间</li>
</ul>
</li>
<li>因此折半插入排序将两个操作分开，并将查找部分优化为折半查找的操作</li>
</ul>
<h4 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,low,high,mid;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) <span class="comment">//将A[1]-A[n]插入到前面已排序的序列中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cur=A[i];</span><br><span class="line">        low=<span class="number">0</span>;high=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)<span class="comment">//查找</span></span><br><span class="line">        &#123;</span><br><span class="line">            mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[mid]&gt;cur) high=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> low=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;high;--j)<span class="comment">//插入</span></span><br><span class="line">            A[j+<span class="number">1</span>]=A[j];<span class="comment">//向后挪位置</span></span><br><span class="line">        A[high+<span class="number">1</span>]=cur;<span class="comment">//复制到应该插入的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 附折半查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Binary_Search</span><span class="params">(<span class="keyword">int</span> L[],<span class="keyword">int</span> key,<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low=<span class="number">0</span>,high=size<span class="number">-1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=(low+high/)<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(L[mid]==key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L[mid]&gt;key)</span><br><span class="line">            high=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度及稳定性-3"><a href="#复杂度及稳定性-3" class="headerlink" title="复杂度及稳定性"></a>复杂度及稳定性</h4><ul>
<li>平均复杂度<ul>
<li>$O(n^2)$ ：由于只对查找部分进行了优化，而移动次数没有变化，对每个元素仍然需要移动 <code>n级</code> 次</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>$O(1)$：同上</li>
</ul>
</li>
<li>稳定性<ul>
<li>稳定</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>while(low&lt;high)与while(low&lt;=high)</strong></p>
<p>在快排中，是<code>while(low&lt;high)</code>，由于快排中的算法思想是<code>low++</code>和<code>high--</code>，每次仅做一步的移动，因此以<code>low&lt;high</code>作为终止条件，跳出循环时总能到达<code>low==high</code>；同时由于快排中是找到位置并进行赋值即可，所以可以跳出循环后再进行赋值。</p>
<p>而在折半查找中，以<code>mid</code>的左右对<code>low</code>和<code>high</code>进行重新赋值，因此并不一定每次只移动一步，一次可能会移动很多步，如果使用<code>low&lt;high</code>循环的话，最后跳出循环的时并不能保障<code>low</code>会等于<code>high</code>，其实<code>low</code>有可能会大于<code>high</code>，而使用<code>low&lt;=high</code>循环的话，则可以保障跳出循环是一定有<code>low&gt;high</code>，此时跳出循环的位置以<code>mid</code>值为准，则应该为<code>high+1</code>；再由于查找中需要返回匹配的位置，因此需要对最后一个数也加以判断，因此需要<code>=</code>的条件。</p>
</blockquote>
<h3 id="希尔排序（缩小增量排序）"><a href="#希尔排序（缩小增量排序）" class="headerlink" title="希尔排序（缩小增量排序）"></a>希尔排序（缩小增量排序）</h3><h4 id="方法-4"><a href="#方法-4" class="headerlink" title="方法"></a>方法</h4><ul>
<li>将待排序的表分割成若干个子表，分别进行直接插入排序，当整个表已经基本有序之后，再进行整体的一次直接插入排序</li>
<li>先取一个小于n的步长 $d_1$，把表中的全部记录分成$d_1$个组，所有距离为$d_1$的倍数的记录放在同一个组里，然后对各组进行直接插入排序；然后取第二个步长$d_2&lt;d_1$，重复上述过程，知道$d_t=1$，再进行直接插入排序</li>
<li>一种增量序列的方法是：$d_1=n/2;d_{i+1}=⌊d_1/2⌋$，且最后一个增量为1 </li>
</ul>
<p><img src="/2020/06/02/算法整理/排序/F:/blog\source\_posts\算法整理\排序\希尔排序.gif" alt="希尔排序"></p>
<h4 id="算法-4"><a href="#算法-4" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//动图是分组执行，实际操作是多个分组交替执行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> dk=n/<span class="number">2</span>;dk&gt;=<span class="number">1</span>;dk=dk/<span class="number">2</span>) <span class="comment">//每个步长</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=dk;i&lt;n;++i) <span class="comment">//每一组</span></span><br><span class="line">            <span class="keyword">if</span>(A[i]&lt;A[i-dk])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> cur=A[i];</span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                <span class="keyword">for</span>(j=i-dk;j&gt;=<span class="number">0</span>&amp;&amp;cur&lt;A[j];j-=dk)</span><br><span class="line">                    A[j+dk]=A[j];</span><br><span class="line">                A[j+dk]=cur;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度及稳定性-4"><a href="#复杂度及稳定性-4" class="headerlink" title="复杂度及稳定性"></a>复杂度及稳定性</h4><ul>
<li>平均复杂度<ul>
<li>$O(n^{1.3})$ ：依赖于增量序列</li>
</ul>
</li>
<li>最坏复杂度<ul>
<li>$O(n^2)$ ：</li>
</ul>
</li>
<li>最优复杂度<ul>
<li>$O(n)$：</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>$O(1)$：不需要额外的空间利用。</li>
</ul>
</li>
<li>稳定性<ul>
<li>不稳定：当相同关键字被划分到不同的组时，相对位置可能会发生变化</li>
</ul>
</li>
</ul>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="方法-5"><a href="#方法-5" class="headerlink" title="方法"></a>方法</h4><ul>
<li>假设排序表为<code>L[1...n]</code>，第<code>i</code>趟操作就是从<code>L[i...n]</code>中选择选择关键字最小的元素与<code>L[i]</code>进行交换，每一趟排序可以确定一个元素的最终位置。</li>
</ul>
<p><img src="/2020/06/02/算法整理/排序/F:/blog\source\_posts\算法整理\排序\选择排序.gif" alt="选择排序"></p>
<h4 id="算法-5"><a href="#算法-5" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min=i; <span class="comment">//顺序位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)<span class="comment">//从i+1开始，找最小的</span></span><br><span class="line">            <span class="keyword">if</span>(A[j]&lt;A[min]) min=j;</span><br><span class="line">        <span class="keyword">if</span>(min!=i)</span><br><span class="line">            swap(A[i],A[min]);<span class="comment">//第i小的位置进行交换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度及稳定性-5"><a href="#复杂度及稳定性-5" class="headerlink" title="复杂度及稳定性"></a>复杂度及稳定性</h4><ul>
<li>平均复杂度<ul>
<li>$O(n^2)$ ：元素间的比较次数与数组原始顺序无关，始终<code>n(n-1)/2</code>次，所以时间复杂度始终是$O(n^2)$</li>
</ul>
</li>
<li>最坏复杂度<ul>
<li>$O(n^2)$ ：</li>
</ul>
</li>
<li>最优复杂度<ul>
<li>$O(n^2 )$：</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>$O(1)$：不额外依赖空间</li>
</ul>
</li>
<li>稳定性<ul>
<li>不稳定：在进行交换的时候，若min值在后面，会将前面位置的未知值交换掉，而若此未知值在数组后边有相关的关键字值，顺序可能会被改变。如：<code>L={2,-2-,1}-&gt;L={1,-2-,2}</code></li>
</ul>
</li>
</ul>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="方法-6"><a href="#方法-6" class="headerlink" title="方法"></a>方法</h4><ul>
<li>堆：近似完全二叉树的结构，并满足子节点的键值或索引总是小于（或大于）它的父节点——大顶堆（小顶堆）</li>
<li>将初始待排序关键字序列<code>(R1,R2….Rn)</code>构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li>
<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li>
</ul>
<p><img src="/2020/06/02/算法整理/排序/F:/blog\source\_posts\算法整理\排序\堆排序.gif" alt="堆排序"></p>
<h4 id="算法-6"><a href="#算法-6" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> k,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//----k为需要调整的结点编号，从0开始编号;len为堆长度</span></span><br><span class="line">    <span class="keyword">int</span> cur=A[k];</span><br><span class="line">    <span class="comment">//左孩子，第一个节点编号为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*k+<span class="number">1</span>;i&lt;len;i=i*<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//右子树</span></span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>&lt;len &amp;&amp; A[i]&lt;A[i+<span class="number">1</span>])</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(cur&gt;=A[i]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            A[k]=A[i];</span><br><span class="line">            k=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k]=cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--) <span class="comment">//从最后一个结点的父节点开始调整</span></span><br><span class="line">        AdjustDown(A,i<span class="number">-1</span>,len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BuildMaxHeap(A,len);<span class="comment">//初始建立大顶堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--) <span class="comment">//n-1趟交换和建堆</span></span><br><span class="line">    &#123;</span><br><span class="line">        swap(A[i],A[<span class="number">0</span>]);<span class="comment">//输出堆顶元素（和堆底元素交换）</span></span><br><span class="line">        AdjustDown(A,<span class="number">0</span>,i);<span class="comment">//整理，把剩余的i-1个元素整理成堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度及稳定性-6"><a href="#复杂度及稳定性-6" class="headerlink" title="复杂度及稳定性"></a>复杂度及稳定性</h4><ul>
<li>平均复杂度<ul>
<li>$O(nlog_2n)$ ：与树高<code>h</code>有关，建堆的时间为$O(n)$，之后有<code>n-1</code>次的调整操作，每次调整复杂度为$O(h)$</li>
</ul>
</li>
<li>最坏复杂度<ul>
<li>$O(nlog_2n)$ ：</li>
</ul>
</li>
<li>最优复杂度<ul>
<li>$O(nlog_2n)$：</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>$O(1)$：常数个辅助单元</li>
</ul>
</li>
<li>稳定性<ul>
<li>不稳定：如表<code>L={1,-2-,2}</code>，在构造初始堆的时候会将<code>-2-</code>交换到堆顶，此时<code>L={-2-,1,2}</code>，最终排序为<code>L={1,2,-2-}</code></li>
</ul>
</li>
</ul>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="方法-7"><a href="#方法-7" class="headerlink" title="方法"></a>方法</h4><ul>
<li>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为<strong>2-路归并</strong>。 </li>
<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
<p><img src="/2020/06/02/算法整理/排序/F:/blog\source\_posts\算法整理\排序\归并排序.gif" alt="归并排序"></p>
<h4 id="算法-7"><a href="#算法-7" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 也是一个递归的算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//A[low...mid]和A[mid...high]分别有序，现在将他们合并</span></span><br><span class="line">    <span class="keyword">int</span> B[<span class="number">10</span>],i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(k=low;k&lt;=high;k++)</span><br><span class="line">        B[k]=A[k]; <span class="comment">//将A中的值复制到B中</span></span><br><span class="line">    <span class="keyword">for</span>(i=low,j=mid+<span class="number">1</span>,k=i;i&lt;=mid &amp;&amp; j&lt;=high;k++)<span class="comment">//合并两个有序数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(B[i]&lt;=B[j])</span><br><span class="line">            A[k]=B[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[k]=B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) A[k++]=B[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high) A[k++]=B[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        MergeSort(A,low,mid);<span class="comment">//分别有序</span></span><br><span class="line">        MergeSort(A,mid+<span class="number">1</span>,high);</span><br><span class="line">        Merge(A,low,mid,high);<span class="comment">//合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度及稳定性-7"><a href="#复杂度及稳定性-7" class="headerlink" title="复杂度及稳定性"></a>复杂度及稳定性</h4><ul>
<li>平均复杂度<ul>
<li>$O(nlog_2n)$ ：一趟归并的复杂度为$O(n)$——分别遍历所有的值，总共需要$log_2n$趟归并</li>
</ul>
</li>
<li>最坏复杂度<ul>
<li>$O(nlog_2n)$ ：</li>
</ul>
</li>
<li>最优复杂度<ul>
<li>$O(nlog_2n)$：</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>$O(n)$：在合并有序数组时需要创建辅助数组。</li>
</ul>
</li>
<li>稳定性<ul>
<li>稳定：Merge操作不会改变相同关键字的相对次序。</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>if(B[i]&lt;=B[j])
    A[k]=B[i++];
else
    A[k]=B[j++];
</code></pre><p>对于这种带等号不带等号，另一个else的，关于等号的判别，就是等于的关键字保持相对位置不变即可。</p>
</blockquote>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><h4 id="方法-8"><a href="#方法-8" class="headerlink" title="方法"></a>方法</h4><ul>
<li>不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</li>
<li>只能是满足条件的整数（0~n）序列</li>
<li>步骤<ul>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ul>
</li>
</ul>
<p><img src="/2020/06/02/算法整理/排序/F:/blog\source\_posts\算法整理\排序\计数排序.gif" alt="计数排序"></p>
<h4 id="算法-8"><a href="#算法-8" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countsort</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data==<span class="literal">nullptr</span> || len&lt;=<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 确定数组的最大值</span></span><br><span class="line">    <span class="keyword">int</span> max=data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">        <span class="keyword">if</span>(max&lt;data[i]) max=data[i];</span><br><span class="line">    <span class="comment">// 确定统计数组长度并进行初始化</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countData(max+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 遍历数组，统计每个数出现的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        ++countData[data[i]];</span><br><span class="line">    <span class="comment">// 排序数组，某个数出现了几次，便在data里累计输出几次</span></span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=max;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;countData[i];++j)</span><br><span class="line">            data[index++]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度及稳定性-8"><a href="#复杂度及稳定性-8" class="headerlink" title="复杂度及稳定性"></a>复杂度及稳定性</h4><ul>
<li>平均复杂度<ul>
<li>$O(n + k)$ ：k为整数的范围。</li>
</ul>
</li>
<li>最坏复杂度<ul>
<li>$O(n + k)$ ：</li>
</ul>
</li>
<li>最优复杂度<ul>
<li>$O(n + k)$：</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>$O(k)$：额外新建的以max为大小的数组</li>
</ul>
</li>
<li>稳定性<ul>
<li>由于只是对数字进行一个输出，并没有界定是否稳定的说法，下方优化过后的计数排序为稳定排序</li>
</ul>
</li>
</ul>
<blockquote>
<p>当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p>
</blockquote>
<h4 id="计数排序的优化版本"><a href="#计数排序的优化版本" class="headerlink" title="计数排序的优化版本"></a>计数排序的优化版本</h4><ul>
<li><p>将数组大小修改为 <code>最大值-最小值+1</code></p>
</li>
<li><p>统计数组从第二个元素开始，每一个元素都加上前面所有元素之和，此时统计数组中的每个下标对应的值就是该数字的最终排名顺序：</p>
<p><img src="/2020/06/02/算法整理/排序/F:/blog\source\_posts\算法整理\排序\计数-优化.jpg.png" alt="计数-优化.jpg"></p>
</li>
<li><p>新建一个数组存储最后的排序结果，首先对原数组进行逆序遍历，每完成一个数的填充，就对其计数数组中的值减一（参考：<a href="https://www.cnblogs.com/kyoner/p/10604781.html" target="_blank" rel="noopener">什么是计数排序？</a>）</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countsort2(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 确定数组的最大值和最小值</span></span><br><span class="line">    <span class="keyword">int</span> max=data[<span class="number">0</span>],min=data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(max&lt;data[i]) max=data[i];</span><br><span class="line">        <span class="keyword">if</span>(min&gt;data[i]) min=data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定统计数组长度并进行初始化</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countData(max-min+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 遍历数组，统计每个数出现的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        ++countData[data[i]-min];</span><br><span class="line">    <span class="comment">// 对统计数组进行重新变形，使得后面的元素等于前面的元素之和</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;max-min+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=countData[i];</span><br><span class="line">        countData[i]=sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 倒序遍历原始数组，从统计数组中找到正确的位置，输出到结果数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; new_data(len,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        new_data[countData[data[i]-min]<span class="number">-1</span>]=data[i];</span><br><span class="line">        countData[data[i]-min]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;new_data[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> new_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个算法的空间复杂度就是O(n+k)了，因为需要另外新建一个数组存放排序，若直接覆盖原数组由于顺序不同会导致出错。</p>
</blockquote>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><h4 id="方法-9"><a href="#方法-9" class="headerlink" title="方法"></a>方法</h4><ul>
<li>是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</li>
<li>桶排序的基本思想是假设数据在[min,max]之间均匀分布，其中min、max分别指数据中的最小值和最大值。那么将区间[min,max]等分成n份，这n个区间便称为n个桶。将数据加入对应的桶中，然后每个桶内单独排序。由于桶之间有大小关系，因此可以从大到小(或从小到大)将桶中元素放入到数组中。</li>
<li>步骤<ul>
<li>设置一个定量的数组当作空桶；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。</li>
</ul>
</li>
</ul>
<p><img src="/2020/06/02/算法整理/排序/F:/blog\source\_posts\算法整理\排序\桶排序.png" alt="桶排序"></p>
<h4 id="算法-9"><a href="#算法-9" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BucketSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 确定数组的最大值和最小值</span></span><br><span class="line">    <span class="keyword">int</span> max=A[<span class="number">0</span>],min=A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(max&lt;A[i]) max=A[i];</span><br><span class="line">        <span class="keyword">if</span>(min&gt;A[i]) min=A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化桶</span></span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">3</span>;  <span class="comment">// 设置每个桶的默认大小为3</span></span><br><span class="line">    <span class="comment">// 桶的数量</span></span><br><span class="line">    <span class="keyword">int</span> cnt=(max - min) / size + <span class="number">1</span>; </span><br><span class="line">    <span class="comment">// vector&lt;int&gt; a[ ] 是 vector&lt;int&gt; 型的数组，</span></span><br><span class="line">    <span class="comment">// 这数组中的每个元素又都是一个 vector&lt;int&gt; 容器。</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; buckets[cnt];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> bi=(A[i] - min) / size;<span class="comment">//映射到哪个桶</span></span><br><span class="line">        buckets[bi].push_back(A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对每个桶排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)</span><br><span class="line">        sort(buckets[i].begin(),buckets[i].end());</span><br><span class="line">    <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)<span class="comment">//每个桶</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;buckets[i].size();j++)</span><br><span class="line">            A[idx++] = buckets[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度及稳定性-9"><a href="#复杂度及稳定性-9" class="headerlink" title="复杂度及稳定性"></a>复杂度及稳定性</h4><ul>
<li>平均复杂度<ul>
<li>$O(n+k )$ ：k个桶的额外空间</li>
</ul>
</li>
<li>最坏复杂度<ul>
<li>$O(n^2)$ ：</li>
</ul>
</li>
<li>最优复杂度<ul>
<li>$O(n)$：当k==n的时候</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>$O(n+k)$：k个桶的额外空间</li>
</ul>
</li>
<li>稳定性<ul>
<li>稳定：取决于每个桶中的排序方法</li>
</ul>
</li>
</ul>
<blockquote>
<p>桶划分的越小，各个桶之中的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 </p>
</blockquote>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><h4 id="方法-10"><a href="#方法-10" class="headerlink" title="方法"></a>方法</h4><ul>
<li>不基于比较，而是采用多关键字排序的思想（基于关键字各位的大小进行排序），借助“分配”和“收集”两种操作对单逻辑关键字进行排序。可以分为最高位优先和最低位优先排序。</li>
<li>按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</li>
<li>步骤：<ul>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li>
</ul>
</li>
</ul>
<p><img src="/2020/06/02/算法整理/排序/F:/blog\source\_posts\算法整理\排序\基数排序.gif" alt="基数排序"></p>
<h4 id="算法-10"><a href="#算法-10" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;=<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> digit=GetMaxDight(A,len);<span class="comment">//最大位数</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;digit&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> count[<span class="number">10</span>];<span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">int</span> radix = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=digit;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每次分配前对计数器进行清空</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++) count[j]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计每个桶中的记录数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;++j)</span><br><span class="line">            count[(A[j]/radix)%<span class="number">10</span>]++;</span><br><span class="line">        <span class="comment">// 变形记录顺序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;<span class="number">10</span>;j++)</span><br><span class="line">            count[j]=count[j<span class="number">-1</span>]+count[j];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将所有桶中记录依次收集到tmp中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=len<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k=(A[j]/radix)%<span class="number">10</span>;</span><br><span class="line">            tmp[count[k]<span class="number">-1</span>]=A[j];</span><br><span class="line">            count[k]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将临时数组中的内容复制到A中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j++)</span><br><span class="line">            A[j]=tmp[j];</span><br><span class="line">        radix=radix*<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度及稳定性-10"><a href="#复杂度及稳定性-10" class="headerlink" title="复杂度及稳定性"></a>复杂度及稳定性</h4><ul>
<li>平均复杂度<ul>
<li>$O(n * k)$ ：</li>
</ul>
</li>
<li>最坏复杂度<ul>
<li>$O(n * k)$ ：</li>
</ul>
</li>
<li>最优复杂度<ul>
<li>$O(n * k)$：</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>$O(n+k)$：</li>
</ul>
</li>
<li>稳定性<ul>
<li>稳定：基于分别排序与分别收集，是稳定的</li>
</ul>
</li>
</ul>
<p>参考：</p>
<p><a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">十大经典排序算法（动图演示）</a></p>
<p><a href="https://www.cnblogs.com/fnlingnzb-learner/p/9374732.html" target="_blank" rel="noopener">C++经典排序算法总结</a> </p>

      
    </div>

    

    
    
    

    

    

    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------　　　　本文结束　<i class="fa fa-heart"></i>　感谢您的阅读　　　　-------------</div>
    
</div>
      
    </div>

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/05/15/算法整理/算法整体安排/" rel="next" title="算法整体安排">
                <i class="fa fa-chevron-left"></i> 算法整体安排
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/06/08/算法整理/经典题型/" rel="prev" title="经典题型">
                经典题型 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/headimg/14.jpg"
                alt="Lavi" />
            
              <p class="site-author-name" itemprop="name">Lavi</p>
              <p class="site-description motion-element" itemprop="description">进化ing</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">63</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/zlovey" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:937198813@qq.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#交换排序"><span class="nav-number">1.</span> <span class="nav-text">交换排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#冒泡排序"><span class="nav-number">1.1.</span> <span class="nav-text">冒泡排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法"><span class="nav-number">1.1.1.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法"><span class="nav-number">1.1.2.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复杂度及稳定性"><span class="nav-number">1.1.3.</span> <span class="nav-text">复杂度及稳定性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速排序"><span class="nav-number">1.2.</span> <span class="nav-text">快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法-1"><span class="nav-number">1.2.2.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复杂度及稳定性-1"><span class="nav-number">1.2.3.</span> <span class="nav-text">复杂度及稳定性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插入排序"><span class="nav-number">2.</span> <span class="nav-text">插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#直接插入排序"><span class="nav-number">2.1.</span> <span class="nav-text">直接插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法-2"><span class="nav-number">2.1.1.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法-2"><span class="nav-number">2.1.2.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复杂度及稳定性-2"><span class="nav-number">2.1.3.</span> <span class="nav-text">复杂度及稳定性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#折半插入排序"><span class="nav-number">2.2.</span> <span class="nav-text">折半插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法-3"><span class="nav-number">2.2.1.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法-3"><span class="nav-number">2.2.2.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复杂度及稳定性-3"><span class="nav-number">2.2.3.</span> <span class="nav-text">复杂度及稳定性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#希尔排序（缩小增量排序）"><span class="nav-number">2.3.</span> <span class="nav-text">希尔排序（缩小增量排序）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法-4"><span class="nav-number">2.3.1.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法-4"><span class="nav-number">2.3.2.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复杂度及稳定性-4"><span class="nav-number">2.3.3.</span> <span class="nav-text">复杂度及稳定性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择排序"><span class="nav-number">2.4.</span> <span class="nav-text">选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法-5"><span class="nav-number">2.4.1.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法-5"><span class="nav-number">2.4.2.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复杂度及稳定性-5"><span class="nav-number">2.4.3.</span> <span class="nav-text">复杂度及稳定性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆排序"><span class="nav-number">2.5.</span> <span class="nav-text">堆排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法-6"><span class="nav-number">2.5.1.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法-6"><span class="nav-number">2.5.2.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复杂度及稳定性-6"><span class="nav-number">2.5.3.</span> <span class="nav-text">复杂度及稳定性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#归并排序"><span class="nav-number">2.6.</span> <span class="nav-text">归并排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法-7"><span class="nav-number">2.6.1.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法-7"><span class="nav-number">2.6.2.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复杂度及稳定性-7"><span class="nav-number">2.6.3.</span> <span class="nav-text">复杂度及稳定性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计数排序"><span class="nav-number">2.7.</span> <span class="nav-text">计数排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法-8"><span class="nav-number">2.7.1.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法-8"><span class="nav-number">2.7.2.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复杂度及稳定性-8"><span class="nav-number">2.7.3.</span> <span class="nav-text">复杂度及稳定性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计数排序的优化版本"><span class="nav-number">2.7.4.</span> <span class="nav-text">计数排序的优化版本</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#桶排序"><span class="nav-number">2.8.</span> <span class="nav-text">桶排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法-9"><span class="nav-number">2.8.1.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法-9"><span class="nav-number">2.8.2.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复杂度及稳定性-9"><span class="nav-number">2.8.3.</span> <span class="nav-text">复杂度及稳定性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基数排序"><span class="nav-number">2.9.</span> <span class="nav-text">基数排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法-10"><span class="nav-number">2.9.1.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法-10"><span class="nav-number">2.9.2.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复杂度及稳定性-10"><span class="nav-number">2.9.3.</span> <span class="nav-text">复杂度及稳定性</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lavi</span>

  

  
</div>


<!--

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Gemini</a> v6.3.0</div>



-->
        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  










  





  

  

  

  
  

  
  

  


  
  

  

  

  

  

  

  
  <script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":true,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":70,"height":140},"mobile":{"show":true},"log":false});</script>
</body>
</html>
