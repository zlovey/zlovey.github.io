<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/cat_32.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/cat_16.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="寻找两个有序数组的中位数  给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。你可以假设 nums1 和 nums2 不会同时为空。 示例 1: 12345输入：nums1 = [1, 3]nums2 = [2]输出：则中位数是 2.0">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode-笔记">
<meta property="og:url" content="http://yoursite.com/2020/02/22/leetcode/leetcode-笔记/index.html">
<meta property="og:site_name" content="Garden">
<meta property="og:description" content="寻找两个有序数组的中位数  给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。你可以假设 nums1 和 nums2 不会同时为空。 示例 1: 12345输入：nums1 = [1, 3]nums2 = [2]输出：则中位数是 2.0">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2020/02/22/leetcode/leetcode-笔记/4-1.png">
<meta property="og:image" content="http://yoursite.com/2020/02/22/leetcode/leetcode-笔记/4-2.png">
<meta property="og:image" content="http://yoursite.com/2020/02/22/leetcode/leetcode-笔记/57-1.jpg.png">
<meta property="og:image" content="http://yoursite.com/2020/02/22/leetcode/leetcode-笔记/57-2.jpg.png">
<meta property="og:image" content="http://yoursite.com/2020/02/22/leetcode/leetcode-笔记/57-3.jpg.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/164a736e22a59a44e7e51e79e2f22f77d392fcd4dc621ea0083a91bd86855884.jpg">
<meta property="og:image" content="https://pic.leetcode-cn.com/0ccb79ccd1536af655f460c8e8ab3cb4e88e7a229c28ccd850023316cbb4ffb2.jpg">
<meta property="og:image" content="http://yoursite.com/2020/02/22/leetcode/leetcode-笔记/「动态规划」问题的思考方向.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/3c4ca880f2dd7463e15ddf7bbd59e2f7d11434b7dbc69b55893660012726ee88.jpg">
<meta property="og:image" content="https://pic.leetcode-cn.com/d9546795e5c73d06b7c77645aef92413f794b3850a62492682a46eb00c9ee711.jpg">
<meta property="og:image" content="https://pic.leetcode-cn.com/4ba4319f13bee429bb95ba119dcaefe71c9644bcf9e9be3ba2637d13fcccd3d6.jpg">
<meta property="og:image" content="https://pic.leetcode-cn.com/05e76869add71c1cbf396bb89ee5ad7f560cc6c5e60926ceaef00a3bbc32c9e4.jpg">
<meta property="og:image" content="https://pic.leetcode-cn.com/1fc56a2ecb6b67ccb5262b5cc3cfcff3041fdc0c6cd8cb0c329ef869644253a4.jpg">
<meta property="og:image" content="https://pic.leetcode-cn.com/74627724154804d8aa7062d1026ffeffa9f6202c1afb38603b91f7eb83eaec17.jpg">
<meta property="og:image" content="https://pic.leetcode-cn.com/73ec2e14a7501999ccd6e60c77bd08415ccdf36fc6da4ab2f29311735a594e66.jpg">
<meta property="og:image" content="https://pic.leetcode-cn.com/d404aff63ecd764aaa70e6bb961a7e4286b8b2afdb6b4ce4bf696fb8eeb55086.jpg">
<meta property="og:image" content="http://yoursite.com/2020/02/22/leetcode/leetcode-笔记/竖式乘法.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/c09dc70d3085792b2b8417843e297f6841fd12f921b0e4fe28a2c4a8dc86dd1e-image.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/0ae239f74ce6ecaaf7c9044291b3fcdc8c5e60ac28dc447b7712a1500f9b3e01-1.png">
<meta property="og:updated_time" content="2020-04-14T12:24:22.369Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="leetcode-笔记">
<meta name="twitter:description" content="寻找两个有序数组的中位数  给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。你可以假设 nums1 和 nums2 不会同时为空。 示例 1: 12345输入：nums1 = [1, 3]nums2 = [2]输出：则中位数是 2.0">
<meta name="twitter:image" content="http://yoursite.com/2020/02/22/leetcode/leetcode-笔记/4-1.png">






  <link rel="canonical" href="http://yoursite.com/2020/02/22/leetcode/leetcode-笔记/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>leetcode-笔记 | Garden</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/zlovey"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Garden</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">
    <a href="/schedule/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />日程表</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/22/leetcode/leetcode-笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lavi">
      <meta itemprop="description" content="进化ing">
      <meta itemprop="image" content="/images/headimg/14.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Garden">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">leetcode-笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-22 16:36:51" itemprop="dateCreated datePublished" datetime="2020-02-22T16:36:51+08:00">2020-02-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-04-14 20:24:22" itemprop="dateModified" datetime="2020-04-14T20:24:22+08:00">2020-04-14</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <ol start="4">
<li><h4 id="寻找两个有序数组的中位数"><a href="#寻找两个有序数组的中位数" class="headerlink" title="寻找两个有序数组的中位数"></a>寻找两个有序数组的中位数</h4></li>
</ol>
<p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。你可以假设 nums1 和 nums2 不会同时为空。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line">输出：</span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure>
<p><strong><a id="more"></a>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line">输出：</span><br><span class="line">则中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure>
<p>题解中利用了求第K小的值的方法，通过每次对k/2小的数进行判断删除和更新使得复杂度保持在O(log(m+n))，官方题解中<em>O</em>(log(min(<em>m</em>,<em>n</em>)))的算法实在没看懂==。下面简单讲一下第k小的思路：</p>
<ul>
<li><p>单独写了一个求第k小的函数getkth()，变量是nums1和nums2的起始位置和结束位置，以及需要求得的k，通过left = (n + m + 1) / 2 与right = (n + m + 2) / 2计算两个中位数边界位置的值*0.5来统一奇偶性的问题。若为奇数，则left==right，若为偶数，则(left+right)*0.5即为中位数</p>
</li>
<li><p>关于函数getkth()：</p>
<ul>
<li><p>首先保证nums1的长度小于nums2，这样可以简便后面的操作（输入时交换）</p>
</li>
<li><p>分别找到nums1和nums2中位置k/2的值，如果nums1的长度小于k/2，那么以nums1的最后一个数值为准</p>
</li>
<li><p><img src="/2020/02/22/leetcode/leetcode-笔记/4-1.png" alt="4-1"></p>
</li>
<li><p>对于两个数中，小的那一个，如上图即3&lt;4，那么3及前面的1,2都可以去掉——当前找的是第k小的，在k/2+k/2的数组中，我们要找的是最大的那个数，而这个数一定不会是在[k/2]值更小的那一边。</p>
</li>
<li><p>黄色的部分是被去掉的</p>
<p><img src="/2020/02/22/leetcode/leetcode-笔记/4-2.png" alt="4-2"></p>
</li>
<li><p>从蓝色的部分继续寻找第k - ( j (对应数组的当前值) - start2 (对应当前数组的起始值) + 1)小的值即可——上例中在剩下蓝色数组中继续寻找k=7-3=4的值</p>
</li>
<li><p>停止条件：</p>
<ul>
<li>当k==1时，选择两个数组中当前最小的即可</li>
<li>当nums1为空时，去找nums2中对应的第k小即可</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 方法一 我又来调库了。。。。 当然是不满足复杂度的</span></span><br><span class="line">        <span class="comment"># nums1.extend(nums2)</span></span><br><span class="line">        <span class="comment"># nums1.sort()  # 注意中位数是排序后的中间数！！</span></span><br><span class="line">        <span class="comment"># n=len(nums1)</span></span><br><span class="line">        <span class="comment"># if n%2!=0:</span></span><br><span class="line">        <span class="comment">#     return nums1[n/2]</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">        <span class="comment">#     # 注意float 要在运算前就将其置为float，在运算之后置的无效</span></span><br><span class="line">        <span class="comment">#     # 其实*0.5就好了============</span></span><br><span class="line">        <span class="comment">#     return (float(nums1[n//2])+float(nums1[n//2-1]))/2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 正确解法 前方高能警告 可以查看题解最高赞，带图讲的很清楚</span></span><br><span class="line">        <span class="comment"># 中位数也类似于求第k小的数，只不过k=(m+n)/2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 自己试着写写呢，真不愧是困难啊，，，，</span></span><br><span class="line">        <span class="comment"># ai..........注意下标。。。。</span></span><br><span class="line">        n = len(nums1)</span><br><span class="line">        m = len(nums2)</span><br><span class="line">        <span class="comment"># 中位数求得应该为(left位置-1的值+right位置-1的值)/2</span></span><br><span class="line">        <span class="comment"># 这里是没有-1的</span></span><br><span class="line">        <span class="comment"># 定位</span></span><br><span class="line">        left = (n + m + <span class="number">1</span>) / <span class="number">2</span> </span><br><span class="line">        right = (n + m + <span class="number">2</span>) / <span class="number">2</span></span><br><span class="line">        <span class="comment"># 将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。</span></span><br><span class="line">        <span class="keyword">return</span> (self.__getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, left) + self.__getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, right)) * <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getKth</span><span class="params">(self,nums1, start1, end1, nums2, start2, end2, k)</span>:</span><span class="comment"># 求第k小的值 </span></span><br><span class="line">        len1 = end1 - start1 + <span class="number">1</span> <span class="comment">#数的个数=脚标+1</span></span><br><span class="line">        len2 = end2 - start2 + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1 </span></span><br><span class="line">        <span class="keyword">if</span> (len1 &gt; len2): <span class="comment"># 交换两个数组的位置</span></span><br><span class="line">            <span class="keyword">return</span> self.__getKth(nums2, start2, end2, nums1, start1, end1, k)</span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">0</span>): <span class="comment"># nums1数组已经被完全去掉了，直接在Nums2中找第k小的就可以了</span></span><br><span class="line">            <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>):<span class="comment"># 停止条件，已经遍历到第1小的，返回两个数组中小的那一个即可</span></span><br><span class="line">            <span class="keyword">return</span> min(nums1[start1], nums2[start2])</span><br><span class="line">        <span class="comment"># 将两个数组跳转到k/2的位置，对小的那个数组k/2位置前面的所有数据删去（不是第k小的），同时更新k</span></span><br><span class="line">        i = start1 + min(len1, k / <span class="number">2</span>) - <span class="number">1</span></span><br><span class="line">        j = start2 + min(len2, k / <span class="number">2</span>) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &gt; nums2[j]):<span class="comment"># 把nums2的j前面的数剪掉</span></span><br><span class="line">            <span class="keyword">return</span> self.__getKth(nums1, start1, end1, nums2, j + <span class="number">1</span>, end2, k - (j - start2 + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__getKth(nums1, i + <span class="number">1</span>, end1, nums2, start2, end2, k - (i - start1 + <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>参考高赞题解 图源：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/</a></p>
<hr>
<ol start="41">
<li><h4 id="缺失的第一个正数难度"><a href="#缺失的第一个正数难度" class="headerlink" title="缺失的第一个正数难度"></a>缺失的第一个正数难度</h4></li>
</ol>
<p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,0]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,-1,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,8,9,11,12]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<p>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。</p>
<p>最简单的是O(n^2)遍历：从1开始遍历，找数组中没有的第一个正数，需要注意0 1 2 前面都满足，则返回len+1</p>
<p>满足条件的O(n)及O(1)：</p>
<ul>
<li>基本思路：<ul>
<li>桶排序 —— 即鸽笼原理 —— 即一个萝卜一个坑</li>
<li>通过遍历两次来解决</li>
<li>第一次遍历使得在第i索引位置的数应该为i+1：通过将该数与其应在的位置上的数进行交换</li>
<li>第二次遍历寻找不符合要求的索引i即返回，如果遍历结束都满足，则返回len(nums)+1</li>
</ul>
</li>
<li>but 呢，按照这个基本思路写下来，硬生生进了三个坑======<ul>
<li>坑1：在循环时，要使用while而不是if，因为在交换时会把没有遍历过的数据交换过来，通过while 的方式保证每个数都经过了交换<ul>
<li>如 -1 4 3 1 在交换了4与1之后得到 -1 1 3 4，此时1并没有经过遍历，所以还要 1 -1 3 4交换</li>
</ul>
</li>
<li>坑2：由于使用while递归，所以在交换前后两个数字大小相同的时候，会 陷入死循环，所以将nums[i]-1!=i的判断条件修改为nums[nums[i]-1]!=nums[i]即可。</li>
<li>坑3：在本题中，交换操作需要借助函数进行，或者重新令为新的变量调用（可参考<a href="https://blog.csdn.net/qq_43029747/article/details/95992657）" target="_blank" rel="noopener">https://blog.csdn.net/qq_43029747/article/details/95992657）</a><ul>
<li>如果直接调用，应该写为：nums[i],nums[nums[i]-1]=nums[nums[i]-1],nums[i]</li>
<li>下面我们来看看python交换的操作：比如a , b = b , a <ul>
<li>python在交换的过程中会生成一个元组 c，并且c = (b ,a)，然后进行a = c[0] ， b = c[1] 的操作</li>
</ul>
</li>
<li>经简单实验可知：(i==1)<ul>
<li>nums[i],nums[nums[i]-i]=nums[4-i],nums[i]就会出现问题<ul>
<li>由上述原理可知，nums[i]先被赋值为nums[3]（=1），然后才将nums[nums[i]-i]赋值为nums[i]，此时nums[i]已经被置为1了，此时是将nums[0]的值置为1，故会出现错误</li>
</ul>
</li>
<li>nums[i],nums[4-i]=nums[nums[i]-i],nums[i]就没有问题<ul>
<li>由上述可知，先将nums[i]=nums[nums[i]-i]，然后将nums[3]赋为nums[i]，这样交换就没有问题</li>
</ul>
</li>
</ul>
</li>
<li>故在交换的时候，不能重复或者嵌套使用</li>
<li>这种情况可以用函数swap(nums, i, nums[i] - 1)直接传递数字进行就没有问题，不用函数直接使用数字也是没有问题的</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 方法一 库 O(n^2)</span></span><br><span class="line">        <span class="comment"># for i in range(1,len(nums)+2):# +2主要针对[]以及[1]的情况，长度不够</span></span><br><span class="line">        <span class="comment">#     if i not in nums:</span></span><br><span class="line">        <span class="comment">#         return i</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 正规方法</span></span><br><span class="line">        <span class="comment"># 桶排序 —— 即鸽笼原理 —— 即一个萝卜一个坑</span></span><br><span class="line">        <span class="comment"># 通过遍历两次来解决</span></span><br><span class="line">        <span class="comment"># 第一次遍历使得在第i索引位置的数应该为i+1，通过两个数的交换处理</span></span><br><span class="line">        <span class="comment"># 第二次遍历寻找不符合要求的索引i即返回</span></span><br><span class="line">        <span class="comment"># 如果遍历结束都满足，则返回len(nums)+1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="comment"># 坑2 要用while不能用if 因为会有这种情况：</span></span><br><span class="line">            <span class="comment"># 3 4 -1 1 ，遍历第一遍之后会得到 -1 1 3 4，此时1是由位置3与位置1交换，此时的1并没有遍历到应该的位置，所以还应该继续遍历</span></span><br><span class="line">            <span class="comment"># 所以只能用while,确保每一个换过来的数也交换到应该的位置</span></span><br><span class="line">            <span class="comment"># 坑3 如果交换过来的数和原来的数相同，i也不变，会死循环</span></span><br><span class="line">            <span class="comment"># 所以用nums[nums[i]-1]!=nums[i]保证跳出循环</span></span><br><span class="line">            <span class="keyword">while</span> <span class="number">0</span>&lt;nums[i]&lt;=len(nums) <span class="keyword">and</span> nums[nums[i]<span class="number">-1</span>]!=nums[i]:<span class="comment"># 不在该在的位置上</span></span><br><span class="line">                <span class="comment"># </span></span><br><span class="line">                <span class="comment"># 坑1 </span></span><br><span class="line">                <span class="comment"># !!!!!!!!made我终于知道是什么问题了</span></span><br><span class="line">                <span class="comment"># 这里不能直接进行交换，而需要借助函数来进行操作</span></span><br><span class="line">                self.__swap(nums, i, nums[i] - <span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 因为这样的话，交换的两个数里边都有nums[i]，会交换前后相互交叉，nums[nums[i]-1]由于交换后nums[i]值就为1，所以又与nums[0]再进行了交换，反正。。。蛮复杂的，不能这样写</span></span><br><span class="line">                <span class="comment"># 用函数就可以直接传递数字进行就没有问题，不用函数直接使用数字也是没有问题的</span></span><br><span class="line">                <span class="comment"># 经实验：</span></span><br><span class="line">                <span class="comment"># nums[i],nums[nums[i]-i]=nums[4-i],nums[i]就会出现问题，而</span></span><br><span class="line">                <span class="comment"># nums[i],nums[4-i]=nums[nums[i]-i],nums[i]就没有问题——也许是前面的不能有问题吧</span></span><br><span class="line">                <span class="comment"># nums[i],nums[nums[i]-1]=nums[nums[i]-1],nums[i]# 与它该在的位置上的数进行交换</span></span><br><span class="line">                <span class="comment"># python交换的原理a , b = b , a </span></span><br><span class="line">                <span class="comment"># 在python中，会在过程中生成一个元组 c，并且c = (b ,a)，然后进行a = c[0] ， b = c[1] 的操作</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]!=i+<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> len(nums)+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__swap</span><span class="params">(self, nums, index1, index2)</span>:</span></span><br><span class="line">        nums[index1], nums[index2] = nums[index2], nums[index1]</span><br></pre></td></tr></table></figure>
<p>参考题解：<a href="https://leetcode-cn.com/problems/first-missing-positive/solution/tong-pai-xu-python-dai-ma-by-liweiwei1419/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/first-missing-positive/solution/tong-pai-xu-python-dai-ma-by-liweiwei1419/</a></p>
<hr>
<h4 id="57-插入区间"><a href="#57-插入区间" class="headerlink" title="57. 插入区间"></a><a href="https://leetcode-cn.com/problems/insert-interval/" target="_blank" rel="noopener">57. 插入区间</a></h4><p>给出一个<em>无重叠的 ，</em>按照区间起始端点排序的区间列表。</p>
<p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: intervals = [[1,3],[6,9]], newInterval = [2,5]</span><br><span class="line">输出: [[1,5],[6,9]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]</span><br><span class="line">输出: [[1,2],[3,10],[12,16]]</span><br><span class="line">解释: 这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</span><br></pre></td></tr></table></figure>
<p>就是这种，带点逻辑性的问题，就做不出来，绕着绕着就把自己绕进去了</p>
<p>！</p>
<p>！</p>
<p>哎</p>
<p>其实看答案人家逻辑就挺清晰的。。</p>
<p>整个问题分为三段：</p>
<ul>
<li><p>在新插入区间之前的部分：</p>
<p><img src="/2020/02/22/leetcode/leetcode-笔记/57-1.jpg.png" alt="57-1.jpg" style="zoom:33%;"></p>
</li>
<li><p>与待插入区间相交的中间</p>
<p><img src="/2020/02/22/leetcode/leetcode-笔记/57-2.jpg.png" alt="57-2.jpg" style="zoom:33%;"></p>
</li>
<li><p>已完成合并之后，原区间剩下的部分</p>
<p><img src="/2020/02/22/leetcode/leetcode-笔记/57-3.jpg.png" alt="57-3.jpg" style="zoom:33%;"></p>
</li>
</ul>
<p>直接参考具体代码即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, intervals, newInterval)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type intervals: List[List[int]]</span></span><br><span class="line"><span class="string">        :type newInterval: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 自己写总是弯弯绕绕，很多情况考虑不到，越写越乱，逐渐放弃================</span></span><br><span class="line">        <span class="comment"># 。。。。。。。。。。。。。</span></span><br><span class="line">        <span class="comment"># 方法一 贪心算法  </span></span><br><span class="line">     </span><br><span class="line">        i = <span class="number">0</span> </span><br><span class="line">        n = len(intervals)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 找左边重合区域</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> newInterval[<span class="number">0</span>] &gt; intervals[i][<span class="number">1</span>]:<span class="comment"># 第一阶段</span></span><br><span class="line">            res.append(intervals[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        tmp = [newInterval[<span class="number">0</span>], newInterval[<span class="number">1</span>]]</span><br><span class="line">        <span class="comment"># 找右边重合区域</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> newInterval[<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>]:<span class="comment"># 第二阶段 利用Max 和min即可</span></span><br><span class="line">            tmp[<span class="number">0</span>] = min(tmp[<span class="number">0</span>], intervals[i][<span class="number">0</span>])</span><br><span class="line">            tmp[<span class="number">1</span>] = max(tmp[<span class="number">1</span>], intervals[i][<span class="number">1</span>])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        res.append(tmp)</span><br><span class="line">        <span class="keyword">while</span> i &lt; n : <span class="comment">#第三阶段</span></span><br><span class="line">            res.append(intervals[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>参考题解：</p>
<p><a href="https://leetcode-cn.com/problems/insert-interval/solution/chang-gui-si-kao-by-powcai/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/insert-interval/solution/chang-gui-si-kao-by-powcai/</a></p>
<p><a href="https://leetcode-cn.com/problems/insert-interval/solution/cha-ru-qu-jian-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/insert-interval/solution/cha-ru-qu-jian-by-leetcode/</a></p>
<hr>
<h4 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a></h4><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png" alt="img"></p>
<p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 <code>[2,1,5,6,2,3]</code>。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png" alt="img"></p>
<p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 <code>10</code> 个单位。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,1,5,6,2,3]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure>
<p>主要使用了一个单调栈的方法，使递增的数放进栈中，然后对不再递增的数 进行Pop并计算的操作，总共只把所以数据遍历了一遍，所以时间空间O(n)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type heights: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">### 方法————单调栈</span></span><br><span class="line">        <span class="comment"># 时间复杂度：O(n) n个数字每个会被压栈弹栈各一次</span></span><br><span class="line">        <span class="comment"># 空间复杂度：O(n) 用来存放栈中元素。</span></span><br><span class="line">        <span class="comment"># 可参考博客 https://blog.csdn.net/Zolewit/article/details/88863970，很清楚</span></span><br><span class="line">        <span class="comment"># 首先题目的解为  能完全覆盖第i条的最小的面积 的最大值</span></span><br><span class="line">        <span class="comment"># 其次 对能完全覆盖第i条的最小面积：高为heights[i]，宽为从左到右，左边为i的左边第一个比heights[i]小的值的index，右边为第一个比heights[i]小的值的index</span></span><br><span class="line">        <span class="comment"># 最后，这个单调栈嘛，就是保证里边的数都是单调的，一旦不是单调了，则pop开始计算</span></span><br><span class="line">        heights = [<span class="number">0</span>] + heights + [<span class="number">0</span>]<span class="comment"># 在左右添加0位，使得最小，省去判断是否为空</span></span><br><span class="line">        stack=[]</span><br><span class="line">        square=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(heights)):<span class="comment"># 计算每个能完全覆盖第i条的最小面积</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> heights[i]&lt;heights[stack[<span class="number">-1</span>]]:</span><br><span class="line">                top=stack.pop() <span class="comment">#现在计算的是覆盖第top条的最小面积</span></span><br><span class="line">                <span class="comment"># stack已经Pop了，现在的栈顶是左边第一个比top小的index</span></span><br><span class="line">                square=max(square,heights[top]*(i - stack[<span class="number">-1</span>] - <span class="number">1</span>))</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> square</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 方法一 ——————会超出时间限制========</span></span><br><span class="line">        <span class="comment"># 时间复杂度：O(n^2) 需要枚举所有可能的柱子对。</span></span><br><span class="line">        <span class="comment"># 空间复杂度：O(1) 不需要额外的空间。</span></span><br><span class="line">        <span class="comment"># 我们可以基于纯暴力O(n^3)的算法进行一点点修改来优化算法。可以用前一对柱子之间的最低高度来求出当前柱子对间的最低高度。</span></span><br><span class="line">        <span class="comment"># square=0</span></span><br><span class="line">        <span class="comment"># for i in range(len(heights)):</span></span><br><span class="line">        <span class="comment">#     mini=heights[left]# 初始化为当前最左边的值即可</span></span><br><span class="line">        <span class="comment">#     for j in range(i,len(heights)):</span></span><br><span class="line">        <span class="comment">#         mini=min(heights[j],mini)# 每次将当前的值与最小值进行比较，得到当前i和j之间的最小值mini</span></span><br><span class="line">        <span class="comment">#         square=max(square,mini*(j-i+1))</span></span><br><span class="line">        <span class="comment"># return square</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 方法二 分治 ——————会超出时间限制========</span></span><br><span class="line">        <span class="comment"># 时间复杂度：</span></span><br><span class="line">        <span class="comment"># 平均开销：O(nlogn)</span></span><br><span class="line">        <span class="comment"># 最坏情况：O(n^2) 如果数组中的数字是有序的，分治算法将没有任何优化效果。</span></span><br><span class="line">        <span class="comment"># 空间复杂度：O(n) 最坏情况下递归需要O(n)的空间。</span></span><br><span class="line">        <span class="comment"># 每次找到当前最矮的木板，计算以其为高度，以当前边沿为宽度的最大面积，然后以该木板分开的左右两边中继续寻找最大的面积</span></span><br><span class="line">    <span class="comment">#     return self.__calculateArea(heights, 0, len(heights)-1)</span></span><br><span class="line">    <span class="comment"># def __calculateArea(self, heights, left, right):</span></span><br><span class="line">    <span class="comment">#     if left&gt;right:#终止条件</span></span><br><span class="line">    <span class="comment">#         return 0</span></span><br><span class="line">    <span class="comment">#     minindex = left</span></span><br><span class="line">    <span class="comment">#     for i in range(left,right+1):#遍历找到当前最小的值及index</span></span><br><span class="line">    <span class="comment">#           if heights[i]&lt;heights[minindex]:</span></span><br><span class="line">    <span class="comment">#               minindex=i</span></span><br><span class="line">    <span class="comment">#     return max(heights[minindex]*(right-left+1),self.__calculateArea(heights,left,minindex-1),self.__calculateArea(heights,minindex+1,right))</span></span><br></pre></td></tr></table></figure>
<p>参考：</p>
<p><a href="https://blog.csdn.net/Zolewit/article/details/88863970" target="_blank" rel="noopener">https://blog.csdn.net/Zolewit/article/details/88863970</a></p>
<p>官方题解：<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode/</a></p>
<p>评论区题解等</p>
<hr>
<h4 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123. 买卖股票的最佳时机 III</a></h4><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定的股票在第 <em>i</em> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <em>两笔</em> 交易。</p>
<p><strong>注意:</strong> 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,3,5,0,0,3,1,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。</span><br><span class="line">     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   </span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   </span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1] </span><br><span class="line">输出: 0 </span><br><span class="line">解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>
<p>这是一系列的股票买卖问题，先就这道题给出两个解法，然后就此类问题给出通用解法</p>
<p>参考：</p>
<p>windliang-<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--29/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--29/</a><br>labuladong-<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen/</a></p>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>windliang-<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--29/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--29/</a></p>
<p>用 <code>dp[i][k]</code> 表示前<code>i</code>天最多交易<code>k</code>次的最高收益，那么 <code>dp[i][k]</code> 怎么通过之前的解求出来呢:</p>
<ul>
<li>首先第 <code>i</code> 天可以什么都不操作，今天的最高收益就等于昨天的最高收益 <code>dp[i][k] = dp[i-1][k]</code></li>
<li>而如果选择在第i天卖出：<code>dp[i][k] = prices[i] - prices[j] + dp[j][k-1]</code>，<code>j</code> 取 <code>0 - i</code>。</li>
</ul>
<p>因此，状态转移的方程为<code>dp[i][k] = Max(dp[i-1][k],prices[i] - prices[j] + dp[j][k-1])</code>，<code>j</code> 取 <code>0 - i</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> K = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][K + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= K; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123; </span><br><span class="line">            <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">            <span class="comment">//找出第 0 天到第 i 天 prices[buy] - dp[buy][k - 1] 的最小值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> buy = <span class="number">0</span>; buy &lt;= i; buy++) &#123; </span><br><span class="line">                min = Math.min(prices[buy] - dp[buy][k - <span class="number">1</span>], min);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较不操作和选择一天买入的哪个值更大</span></span><br><span class="line">            dp[i][k] = Math.max(dp[i - <span class="number">1</span>][k], prices[i] - min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][K];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过化简之后可以得到代码：（其实与状态机的很相似）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">int</span> dp1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min1 = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> min2 = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            min1 = Math.min(prices[i] - <span class="number">0</span>, min1);</span><br><span class="line">            dp1 = Math.max(dp1, prices[i] - min1);</span><br><span class="line"></span><br><span class="line">            min2 = Math.min(prices[i] - dp1, min2);</span><br><span class="line">            dp2 = Math.max(dp2, prices[i] - min2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h4><p>基本转自 labuladong-<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen/</a></p>
<p>通解：</p>
<p>利用「状态」进行穷举。具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。</p>
<p>这个问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态。比如 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 dp[2][3][0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">base case：</span><br><span class="line">dp[-1][k][0] = dp[i][0][0] = 0</span><br><span class="line">dp[-1][k][1] = dp[i][0][1] = -infinity</span><br><span class="line">解释：</span><br><span class="line">dp[-1][k][0]=0</span><br><span class="line">因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。</span><br><span class="line">dp[-1][k][1] = -infinity</span><br><span class="line">解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。</span><br><span class="line">dp[i][0][0] = 0</span><br><span class="line">解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。</span><br><span class="line">dp[i][0][1] = -infinity</span><br><span class="line">解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。</span><br><span class="line"></span><br><span class="line">状态转移方程：</span><br><span class="line">dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])</span><br><span class="line">解释：今天我没有持有股票，有两种可能：</span><br><span class="line">要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；</span><br><span class="line">要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。</span><br><span class="line">dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])</span><br><span class="line">解释：今天我持有着股票，有两种可能：</span><br><span class="line">要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；</span><br><span class="line">要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。</span><br></pre></td></tr></table></figure>
<p>第一题，k = 1</p>
<p>套状态转移方程，根据 base case，可以做一些化简：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])</span><br><span class="line">dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) </span><br><span class="line">            = max(dp[i-1][1][1], -prices[i])</span><br><span class="line">解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。</span><br></pre></td></tr></table></figure>
<p>现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。</p>
<p>可以进行进一步化简去掉所有 k：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span><br><span class="line">dp[i][1] = max(dp[i-1][1], -prices[i])</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码：(c++)</span></span><br><span class="line"><span class="keyword">int</span> n = prices.length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = Math.max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = Math.max(dp[i<span class="number">-1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line"><span class="comment">//显然 i = 0 时 dp[i-1] 是不合法的。</span></span><br><span class="line"><span class="comment">//这是因为我们没有对 i 的 base case 进行处理。可以这样处理：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// k == 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_k_1</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="comment">// base case: dp[-1][0] = 0, dp[-1][1] = -infinity</span></span><br><span class="line">    <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span></span><br><span class="line">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        <span class="comment">// dp[i][1] = max(dp[i-1][1], -prices[i])</span></span><br><span class="line">        dp_i_1 = Math.max(dp_i_1, -prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前面的k=1或者inf无限次，可以不计入考虑当中</span></span><br><span class="line"><span class="comment"># 本题中k=2，需要考虑k不同的影响，因此需要对四个状态分别进行更新</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 每天我们其实是有四个状态，买入当前价格的股票，以当前价格的股票卖出。第二次买入股票，第二次卖出股票。</span></span><br><span class="line">        <span class="comment"># s0代表初始状态，初始时钱是0。s1代表第一次买入后当前的钱，s2代表第一次卖出后当前的钱，s3代表第二次买入后当前的钱，s4代表第二次卖出后当前的钱。</span></span><br><span class="line">        <span class="comment"># 然后我们只需要更新每天的这四个状态即可。</span></span><br><span class="line">        <span class="keyword">if</span> len(prices)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        s1,s3=-sys.maxsize - <span class="number">1</span></span><br><span class="line">        s2,s4=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)):</span><br><span class="line">            s1 = max(s1, -prices[i]) <span class="comment">#买入价格更低的股</span></span><br><span class="line">            s2 = max(s2, s1+prices[i]) <span class="comment">#卖出当前股，或者不操作</span></span><br><span class="line">            s3 = max(s3, s2-prices[i]) <span class="comment">#第二次买入，或者不操作</span></span><br><span class="line">            s4 = max(s4, s3+prices[i]) <span class="comment">#第二次卖出，或者不操作</span></span><br><span class="line">        <span class="keyword">return</span> max(<span class="number">0</span>,s4)<span class="comment"># 赚不了钱 0</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="126-单词接龙-II"><a href="#126-单词接龙-II" class="headerlink" title="126. 单词接龙 II"></a><a href="https://leetcode-cn.com/problems/word-ladder-ii/" target="_blank" rel="noopener">126. 单词接龙 II</a></h4><p>……………………………………………..。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。没看懂，打算把树和图大概捋一遍了再来。。。</p>
<p>给定两个单词（<em>beginWord</em> 和 <em>endWord</em>）和一个字典 <em>wordList</em>，找出所有从 <em>beginWord</em> 到 <em>endWord</em> 的最短转换序列。转换需遵循如下规则：</p>
<ol>
<li>每次转换只能改变一个字母。</li>
<li>转换过程中的中间单词必须是字典中的单词。</li>
</ol>
<p><strong>说明:</strong></p>
<ul>
<li>如果不存在这样的转换序列，返回一个空列表。</li>
<li>所有单词具有相同的长度。</li>
<li>所有单词只由小写字母组成。</li>
<li>字典中不存在重复的单词。</li>
<li>你可以假设 <em>beginWord</em> 和 <em>endWord</em> 是非空的，且二者不相同。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">输出: []</span><br><span class="line"></span><br><span class="line">解释: endWord &quot;cog&quot; 不在字典中，所以不存在符合要求的转换序列。</span><br></pre></td></tr></table></figure>
<p>emmmmmm每次遇到困难的题就完全不行了，有个大概思路也不知道怎么实现了=====</p>
<p>那就还是参考题解区大佬的解法，大概写一下，windliang-<a href="https://leetcode-cn.com/problems/word-ladder-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-3-3/（这个大佬我好像上一题也是抄的他的。。。）" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-ladder-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-3-3/（这个大佬我好像上一题也是抄的他的。。。）</a></p>
<p>可以将本题模拟为一个树的问题，涉及到广度遍历和深度遍历的方法</p>
<p><img src="https://pic.leetcode-cn.com/164a736e22a59a44e7e51e79e2f22f77d392fcd4dc621ea0083a91bd86855884.jpg" alt="img"></p>
<p>两个单词只有一个字母不同时可以相互转换，即可以进行连线，图中橙色表示结束单词，上图橙色的路线即为最短路径。</p>
<h5 id="DFS深度优先遍历"><a href="#DFS深度优先遍历" class="headerlink" title="DFS深度优先遍历"></a>DFS深度优先遍历</h5><p>要找到所有的孩子节点，就需要判断他们之间的连线，即<strong>判断两个单词是否只有一个字母不同</strong>，这里，答主给出了两种写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Way-1，</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordList.size(); i++) &#123;</span><br><span class="line">    String curWord = wordList.get(i);</span><br><span class="line">    <span class="comment">//符合只有一个单词不同，就进入递归</span></span><br><span class="line">    <span class="keyword">if</span> (oneChanged(beginWord, curWord)) &#123;</span><br><span class="line">        <span class="comment">//此时代表可以从 beginWord -&gt; curWord</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> boolean <span class="title">oneChanged</span><span class="params">(String beginWord, String curWord)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; beginWord.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (beginWord.charAt(i) != curWord.charAt(i)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果wordList长度为m，单词长度为n，这种的复杂度就是mn</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Way-2</span></span><br><span class="line"><span class="comment">//dict 就是 wordList，为了提高速度，从 List 转为 HashSet</span></span><br><span class="line"><span class="comment">//cur 是我们要考虑的单词</span></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; getNext(String cur, Set&lt;String&gt; dict) &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] chars = cur.toCharArray();</span><br><span class="line">    <span class="comment">//考虑每一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> old = chars[i];</span><br><span class="line">        <span class="comment">//考虑变成其他所有的字母</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == old) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            chars[i] = c;</span><br><span class="line">            String next = <span class="keyword">new</span> String(chars);</span><br><span class="line">            <span class="comment">//判断 wordList 是否包含修改后的单词</span></span><br><span class="line">            <span class="keyword">if</span> (dict.contains(next)) &#123;</span><br><span class="line">                res.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        chars[i] = old;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直接遍历26个字母查找是否contain，由于用了Hashset所以contain只需要O(1)，故复杂度为O(26n),也即O(n)</span></span><br></pre></td></tr></table></figure>
<p><strong>关于递归的出口</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//到了结尾单词</span></span><br><span class="line"><span class="keyword">if</span> (beginWord.equals(endWord)) &#123;</span><br><span class="line">    <span class="comment">//当前长度更小，清空之前的，加新的路径加入到结果中</span></span><br><span class="line">    <span class="keyword">if</span> (min &gt; temp.size()) &#123;</span><br><span class="line">        ans.clear();</span><br><span class="line">        min = temp.size();</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList&lt;String&gt;(temp));</span><br><span class="line">    <span class="comment">//相等的话就直接加路径加入到结果中</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (min == temp.size()) &#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList&lt;String&gt;(temp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当前的长度到达了 min，还是没有到达结束单词就提前结束</span></span><br><span class="line"><span class="keyword">if</span> (temp.size() &gt;= min) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后你就会发现这两种方法都会超时</p>
<p>然后优化1：如果事先可以了解到最短路径的长度，就可以省去大于该长度的路径</p>
<p>优化2：</p>
<p><img src="https://pic.leetcode-cn.com/0ccb79ccd1536af655f460c8e8ab3cb4e88e7a229c28ccd850023316cbb4ffb2.jpg" alt="img"></p>
<p>假如我们在考虑上图中黄色节点的相邻节点，发现第三层的 <code>abc</code> 在第二层已经考虑过了。所以第三层的 abc 其实不用再考虑了，第三层的  abc 后边的结构一定和第二层后边的结构一样，因为我们要找最短的路径，所以如果产生了最短路径，一定是第二层的 abc 首先达到结束单词。</p>
<p>所以其实我们在考虑第 k 层的某一个单词，如果这个单词在第 1 到 k-1 层已经出现过，我们其实就不过继续向下探索了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 如果不含有结束单词，直接结束，不然后边会造成死循环</span></span><br><span class="line">    <span class="keyword">if</span> (!wordList.contains(endWord)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用 BFS 得到所有的邻居节点,以及每个节点的所在层数</span></span><br><span class="line">    HashMap&lt;String, Integer&gt; distance = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    HashMap&lt;String, ArrayList&lt;String&gt;&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    bfs(beginWord, endWord, wordList, <span class="built_in">map</span>, distance);</span><br><span class="line">    ArrayList&lt;String&gt; temp = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="comment">// temp 用来保存当前的路径</span></span><br><span class="line">    temp.add(beginWord);</span><br><span class="line">    findLaddersHelper(beginWord, endWord, <span class="built_in">map</span>, distance, temp, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findLaddersHelper</span><span class="params">(String beginWord, String endWord, HashMap&lt;String, ArrayList&lt;String&gt;&gt; <span class="built_in">map</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                               HashMap&lt;String, Integer&gt; distance, ArrayList&lt;String&gt; temp, List&lt;List&lt;String&gt;&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beginWord.equals(endWord)) &#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList&lt;String&gt;(temp));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到所有的下一个的节点</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      "a"</span></span><br><span class="line"><span class="comment">      "c"</span></span><br><span class="line"><span class="comment">      ["a","b","c"]*/</span></span><br><span class="line">    <span class="comment">//之所以是 map.getOrDefault 而不是 get，就是上边的情况 get 会出错</span></span><br><span class="line">    ArrayList&lt;String&gt; neighbors = <span class="built_in">map</span>.getOrDefault(beginWord, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">    <span class="keyword">for</span> (String neighbor : neighbors) &#123;</span><br><span class="line">        <span class="comment">//判断层数是否符合</span></span><br><span class="line">        <span class="keyword">if</span> (distance.get(beginWord) + <span class="number">1</span> == distance.get(neighbor)) &#123;</span><br><span class="line">            temp.add(neighbor);</span><br><span class="line">            findLaddersHelper(neighbor, endWord, <span class="built_in">map</span>, distance, temp, ans);</span><br><span class="line">            temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList, HashMap&lt;String, ArrayList&lt;String&gt;&gt; <span class="built_in">map</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                HashMap&lt;String, Integer&gt; distance)</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="built_in">queue</span>.offer(beginWord);</span><br><span class="line">    distance.put(beginWord, <span class="number">0</span>);</span><br><span class="line">    boolean isFound = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">queue</span>.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="built_in">queue</span>.size();</span><br><span class="line">        depth++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">            String temp = <span class="built_in">queue</span>.poll();</span><br><span class="line">            <span class="comment">// 一次性得到所有的下一个的节点</span></span><br><span class="line">            ArrayList&lt;String&gt; neighbors = getNeighbors(temp, dict);</span><br><span class="line">            <span class="built_in">map</span>.put(temp, neighbors);</span><br><span class="line">            <span class="keyword">for</span> (String neighbor : neighbors) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!distance.containsKey(neighbor)) &#123;</span><br><span class="line">                    distance.put(neighbor, depth);</span><br><span class="line">                    <span class="keyword">if</span> (neighbor.equals(endWord)) &#123;</span><br><span class="line">                        isFound = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">queue</span>.offer(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isFound) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;String&gt; getNeighbors(String node, Set&lt;String&gt; dict) &#123;</span><br><span class="line">    ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">char</span> chs[] = node.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch = <span class="string">'a'</span>; ch &lt;= <span class="string">'z'</span>; ch++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chs[i] == ch)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">char</span> old_ch = chs[i];</span><br><span class="line">            chs[i] = ch;</span><br><span class="line">             <span class="keyword">if</span> (dict.contains(String.valueOf(chs))) &#123;</span><br><span class="line">                res.add(String.valueOf(chs));</span><br><span class="line">            &#125;</span><br><span class="line">            chs[i] = old_ch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="345-反转字符串中的元音字母"><a href="#345-反转字符串中的元音字母" class="headerlink" title="345. 反转字符串中的元音字母"></a><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/" target="_blank" rel="noopener">345. 反转字符串中的元音字母</a></h4><p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;hello&quot;</span><br><span class="line">输出: &quot;holle&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;leetcode&quot;</span><br><span class="line">输出: &quot;leotcede&quot;</span><br></pre></td></tr></table></figure>
<p>题目是很简单，但是有的地方还是需要注意一下</p>
<ul>
<li>使用双指针结构更清晰，通过一次遍历即可</li>
<li>str类型不能进行赋值，需要先转换成List类型，在通过<code>&#39;&#39;.join()</code>的方式进行处理</li>
</ul>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 遍历一次，双指针</span></span><br><span class="line">        lit=[<span class="string">'a'</span>,<span class="string">'e'</span>,<span class="string">'i'</span>,<span class="string">'o'</span>,<span class="string">'u'</span>,<span class="string">'A'</span>,<span class="string">'E'</span>,<span class="string">'I'</span>,<span class="string">'O'</span>,<span class="string">'U'</span>]</span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        j=len(s)<span class="number">-1</span></span><br><span class="line">        ret=list(s)</span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            <span class="keyword">if</span> ret[i] <span class="keyword">not</span> <span class="keyword">in</span> lit:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> ret[j] <span class="keyword">not</span> <span class="keyword">in</span> lit:</span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ret[i],ret[j]=ret[j],ret[i]</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(ret)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 自己的傻方法  注意python中str不能赋值，要先改成list</span></span><br><span class="line">         res=[]</span><br><span class="line">         <span class="comment">#'str' object does not support item assignment!!!!!!</span></span><br><span class="line">         ss = list(s)</span><br><span class="line">         <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">             <span class="keyword">if</span> ss[i] <span class="keyword">in</span> [<span class="string">'a'</span>,<span class="string">'e'</span>,<span class="string">'i'</span>,<span class="string">'o'</span>,<span class="string">'u'</span>,<span class="string">'A'</span>,<span class="string">'E'</span>,<span class="string">'I'</span>,<span class="string">'O'</span>,<span class="string">'U'</span>]:<span class="comment">### 注意大写字母！！</span></span><br><span class="line">                 res.append(i)</span><br><span class="line">         print(res)</span><br><span class="line">         <span class="comment"># print(ss)#  ['h', 'e', 'l', 'l', 'o']</span></span><br><span class="line">         <span class="keyword">if</span> len(res)==<span class="number">1</span> <span class="keyword">or</span> len(res)==<span class="number">0</span>:</span><br><span class="line">             <span class="keyword">return</span> s</span><br><span class="line">         <span class="keyword">for</span> i <span class="keyword">in</span> range(int(len(res)/<span class="number">2</span>)):<span class="comment"># 交换</span></span><br><span class="line">             ss[res[i]],ss[res[len(res)<span class="number">-1</span>-i]]=ss[res[len(res)<span class="number">-1</span>-i]],ss[res[i]]</span><br><span class="line">         <span class="keyword">return</span> <span class="string">''</span>.join(ss)</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></h4><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<p>注意空字符串可被认为是有效字符串。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>标准简单题，我只是来放个各位大佬的优秀解法</p>
<p>久了没写要注意一下边界的写法，数据结构栈的标准习题==</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 这曾经是一个标准的栈的数据结构操作题</span></span><br><span class="line">        <span class="comment"># 不知道还写的出来不</span></span><br><span class="line">        <span class="comment"># 还可以</span></span><br><span class="line">         ss=list(s)</span><br><span class="line">         <span class="comment"># 需要处理一个ret为空的边界条件判断的问题</span></span><br><span class="line">         <span class="keyword">if</span> len(ss)==<span class="number">0</span>:</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">         ret=[]</span><br><span class="line">         <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ss)):</span><br><span class="line">             <span class="keyword">if</span> ret == []:</span><br><span class="line">                 ret.append(ss[i])</span><br><span class="line">                 <span class="keyword">continue</span></span><br><span class="line">             <span class="keyword">if</span> ret[<span class="number">-1</span>]==<span class="string">'('</span> <span class="keyword">and</span> ss[i]==<span class="string">')'</span>:</span><br><span class="line">                 ret.pop()</span><br><span class="line">                 <span class="keyword">continue</span></span><br><span class="line">             <span class="keyword">if</span> ret[<span class="number">-1</span>]==<span class="string">'['</span> <span class="keyword">and</span> ss[i]==<span class="string">']'</span>:</span><br><span class="line">                 ret.pop()</span><br><span class="line">                 <span class="keyword">continue</span></span><br><span class="line">             <span class="keyword">if</span> ret[<span class="number">-1</span>]==<span class="string">'&#123;'</span> <span class="keyword">and</span> ss[i]==<span class="string">'&#125;'</span>:</span><br><span class="line">                 ret.pop()</span><br><span class="line">                 <span class="keyword">continue</span></span><br><span class="line">             ret.append(ss[i])</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> ret==[] <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 看看人家老哥的写法</span></span><br><span class="line">        <span class="comment"># 太可恶了====</span></span><br><span class="line">        <span class="keyword">while</span> <span class="string">'&#123;&#125;'</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">'()'</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">'[]'</span> <span class="keyword">in</span> s:</span><br><span class="line">            s = s.replace(<span class="string">'&#123;&#125;'</span>, <span class="string">''</span>)</span><br><span class="line">            s = s.replace(<span class="string">'[]'</span>, <span class="string">''</span>)</span><br><span class="line">            s = s.replace(<span class="string">'()'</span>, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> s == <span class="string">''</span></span><br></pre></td></tr></table></figure>
<p>参考：题目评论区第一</p>
<hr>
<h4 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">125. 验证回文串</a></h4><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p>注意回文串的定义、双指针的用法、ASCII可以直接用字符进行表示、ord()-字符的ASCII、chr()-ASCII对应的字符、lower()函数，isalnum()函数等</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 回文串：正读返读值相同</span></span><br><span class="line">        <span class="comment"># 先转小写 </span></span><br><span class="line">        <span class="comment"># 再去标点 -- 其实使用双指针就好了，标点跳过，直接遍历去标点更浪费时间</span></span><br><span class="line">        <span class="comment"># 感觉需要用到ASCII</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调库 - way1 </span></span><br><span class="line">        <span class="comment"># str.isalnum判断如果全数字或字母，则返回True，否则False</span></span><br><span class="line">        <span class="comment"># filter 过滤满足要求的字符</span></span><br><span class="line">        <span class="comment"># ss = ''.join(filter(str.isalnum,ss)).lower()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># way-2</span></span><br><span class="line">        <span class="comment"># 其实用双指针就好了，换成小写之后，遇到非字母跳过即可</span></span><br><span class="line">        <span class="comment"># 48-57数字 65-90大写字母 97-122小写字母 </span></span><br><span class="line">        <span class="comment"># 转小写的函数只有str字符串可以用哦</span></span><br><span class="line">        <span class="comment"># 其实不用进行赋值操作的时候不用转list</span></span><br><span class="line">        s=s.lower()</span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        j=len(s)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            <span class="comment"># 判断其实也不用ASCII: ss[i]&lt;'0' or '9'&lt;ss[i]&lt;'a'  ss[i]&gt;'z':</span></span><br><span class="line">            <span class="comment"># 这种双指针的一般里边也用while加判断,会稍快一点</span></span><br><span class="line">            <span class="comment"># 跳过标点</span></span><br><span class="line">            <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> (ord(s[i])&lt;<span class="number">48</span> <span class="keyword">or</span> <span class="number">57</span>&lt;ord(s[i])&lt;<span class="number">97</span> <span class="keyword">or</span> ord(s[i])&gt;<span class="number">122</span>):</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> (ord(s[j])&lt;<span class="number">48</span> <span class="keyword">or</span> <span class="number">57</span>&lt;ord(s[j])&lt;<span class="number">97</span> <span class="keyword">or</span> ord(s[j])&gt;<span class="number">122</span>):</span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> s[i]==s[j]:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果大小写也自己写的话，可以像下面这样，需要注意先跳过再进行大小写的转换，因为需要赋值，直接将str对应的字符赋值给一个变量，进行比较</span></span><br><span class="line">        <span class="comment"># way-3</span></span><br><span class="line"></span><br><span class="line">         left, right = <span class="number">0</span>, len(s) - <span class="number">1</span></span><br><span class="line">         case = abs(ord(<span class="string">'a'</span>) - ord(<span class="string">'A'</span>))<span class="comment">###### 32 就好了</span></span><br><span class="line">         <span class="keyword">while</span> left &lt; right:</span><br><span class="line">             <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> self.not_letters_digits(s[left]): left += <span class="number">1</span></span><br><span class="line">             <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> self.not_letters_digits(s[right]): right -= <span class="number">1</span> </span><br><span class="line">             s_l = ord(s[left]) - case <span class="keyword">if</span> s[left] &gt;= <span class="string">'a'</span> <span class="keyword">else</span> ord(s[left])</span><br><span class="line">             s_r = ord(s[right]) - case <span class="keyword">if</span> s[right] &gt;= <span class="string">'a'</span> <span class="keyword">else</span> ord(s[right])</span><br><span class="line">             <span class="keyword">if</span> s_l != s_r: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">             left += <span class="number">1</span></span><br><span class="line">             right -= <span class="number">1</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#     def not_letters_digits(self, c):</span></span><br><span class="line"><span class="comment">#         return not 'A' &lt;= c &lt;= 'Z' and not 'a' &lt;= c &lt;= 'z' and not '0' &lt;= c &lt;= '9'</span></span><br></pre></td></tr></table></figure>
<p>参考：</p>
<p>题解区： jyd-<a href="https://leetcode-cn.com/problems/valid-palindrome/solution/valid-palindrome-shuang-zhi-zhen-fa-by-jyd/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-palindrome/solution/valid-palindrome-shuang-zhi-zhen-fa-by-jyd/</a></p>
<hr>
<h4 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a><a href="https://leetcode-cn.com/problems/add-binary/" target="_blank" rel="noopener">67. 二进制求和</a></h4><p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p>
<p>输入为<strong>非空</strong>字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: a = &quot;11&quot;, b = &quot;1&quot;</span><br><span class="line">输出: &quot;100&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: a = &quot;1010&quot;, b = &quot;1011&quot;</span><br><span class="line">输出: &quot;10101&quot;</span><br></pre></td></tr></table></figure>
<p>对加和的这种问题：</p>
<ul>
<li>在字符串的计算中，短的用 0 补齐即可，减少很多判断</li>
<li><p>从末尾进行遍历计算，并对最后一位进位：</p>
<ul>
<li>第一种，在进行计算时直接拼接字符串，会得到一个反向字符，需要最后再进行翻转</li>
<li>第二种，按照位置给结果字符赋值，最后如果有进位，则在前方进行字符串拼接添加进位</li>
</ul>
</li>
<li><p>时间复杂度：O(n)</p>
</li>
</ul>
<p>需要注意的点（求和这种问题）：</p>
<ul>
<li>三步：<ul>
<li>计算两数及进位的总和——s</li>
<li>计算当前位置的值为: s%2(进制)——r(总和对进制的余数即为当前位置的取值，因为不会超过进制)</li>
<li>计算当前位置的下一个进位: s//2——p(总和对进制的整除数即为当前位置的进位，相当于把这个数分为两个部分 s/2=p……r,除下来的值记作进位，余下来的值即为当前值)</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type a: str</span></span><br><span class="line"><span class="string">        :type b: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 类似加法器</span></span><br><span class="line">        <span class="comment"># 上一个加法器怎么写的来着，又忘了==</span></span><br><span class="line">        <span class="comment"># 自己写了一些，逻辑有些太复杂</span></span><br><span class="line">        <span class="comment"># 看还是不行==</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 注意针对字符串位数不一样的，用0补齐！可以省去很多判断</span></span><br><span class="line">        <span class="comment"># 使得两个字符串长度一致，然后从末尾进行遍历计算，得到最终结果。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对最后的结果是否会多出一位进位，所以会有 2 种处理方式：</span></span><br><span class="line">        <span class="comment"># 第一种，在进行计算时直接拼接字符串，会得到一个反向字符，需要最后再进行翻转</span></span><br><span class="line">        <span class="comment"># 第二种，按照位置给结果字符赋值，最后如果有进位，则在前方进行字符串拼接添加进位</span></span><br><span class="line"></span><br><span class="line">        r, p = <span class="string">''</span>, <span class="number">0</span></span><br><span class="line">        d = len(b) - len(a)<span class="comment"># 两个字符串的长度差</span></span><br><span class="line">        <span class="comment"># 如果d=3,则'0'*3="000",'0'*-3=""</span></span><br><span class="line">        <span class="comment"># 在前面填0</span></span><br><span class="line">        a = <span class="string">'0'</span> * d + a </span><br><span class="line">        b = <span class="string">'0'</span> * -d + b</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(a[::<span class="number">-1</span>], b[::<span class="number">-1</span>]):<span class="comment"># 逆序</span></span><br><span class="line">            s = int(i) + int(j) + p</span><br><span class="line">            r = str(s % <span class="number">2</span>) + r <span class="comment">#字符串直接加在前头就可以</span></span><br><span class="line">            p = s // <span class="number">2</span> <span class="comment"># 超过2即进位，可以仅分为进位与不进位1/0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'1'</span> + r <span class="keyword">if</span> p <span class="keyword">else</span> r</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<p>guanpengchn—<a href="https://leetcode-cn.com/problems/add-binary/solution/hua-jie-suan-fa-67-er-jin-zhi-qiu-he-by-guanpengch/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-binary/solution/hua-jie-suan-fa-67-er-jin-zhi-qiu-he-by-guanpengch/</a><br>QQqun902025048—<a href="https://leetcode-cn.com/problems/add-binary/solution/python-1xing-nei-zhi-han-shu-fei-nei-zhi-jie-fa-by/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-binary/solution/python-1xing-nei-zhi-han-shu-fei-nei-zhi-jie-fa-by/</a></p>
<hr>
<h4 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58. 最后一个单词的长度"></a><a href="https://leetcode-cn.com/problems/length-of-last-word/" target="_blank" rel="noopener">58. 最后一个单词的长度</a></h4><p>给定一个仅包含大小写字母和空格 <code>&#39; &#39;</code> 的字符串 <code>s</code>，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。</p>
<p>如果不存在最后一个单词，请返回 0 。</p>
<p><strong>说明：</strong>一个单词是指仅由字母组成、不包含任何空格字符的 <strong>最大子字符串</strong>。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;Hello World&quot;</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>
<p>比较简单，可以用函数也可以直接写</p>
<p>可以熟悉一下strip()和split()函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i=len(s)<span class="number">-1</span></span><br><span class="line">        cnt=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> s[i]==<span class="string">' '</span>:</span><br><span class="line">             i-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> s[i]!=<span class="string">' '</span>:</span><br><span class="line">            cnt+=<span class="number">1</span></span><br><span class="line">            i-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 函数解：strip()去掉字符串开头或者结尾的空格</span></span><br><span class="line">        <span class="comment"># split()按照要求切割</span></span><br><span class="line">         s=s.strip()</span><br><span class="line">         s=s.split(<span class="string">" "</span>)</span><br><span class="line">         <span class="keyword">return</span> len(s[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">14. 最长公共前缀</a></h4><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>所有输入只包含小写字母 <code>a-z</code> 。</p>
<p>正常做的纵向遍历的解法，看到评论中有说用Python库里边对字符串大小进行比较的min和max方法，不太了解，所以放上来看看</p>
<p>还是要注意初始值的判断，当str为空，str为一个对的这种情况。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type strs: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 大佬们的优秀库操作 way-1</span></span><br><span class="line">        <span class="comment"># python中字符串排序按照ASCII，所以排序之后只需要比较最小的和最大的字符的最大前缀即可</span></span><br><span class="line">         <span class="keyword">if</span> <span class="keyword">not</span> strs: <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">         s1 = min(strs)</span><br><span class="line">         s2 = max(strs)</span><br><span class="line">         print(s1)</span><br><span class="line">         print(s2)</span><br><span class="line">         <span class="keyword">for</span> i,x <span class="keyword">in</span> enumerate(s1):</span><br><span class="line">             <span class="keyword">if</span> x != s2[i]:</span><br><span class="line">                 <span class="keyword">return</span> s2[:i]</span><br><span class="line">         <span class="keyword">return</span> s1</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 大佬们的优秀库操作 way-2</span></span><br><span class="line">        <span class="comment"># 把str看成list然后把输入看成二维数组，左对齐纵向压缩，然后把每项利用集合去重，之后遍历list中找到元素长度大于1之前的就是公共前缀</span></span><br><span class="line">        <span class="comment"># s说实话没看懂，先放着吧。。。。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs: <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        ss = list(map(set, zip(*strs)))</span><br><span class="line">        print(ss)</span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(ss):</span><br><span class="line">            x = list(x)</span><br><span class="line">            <span class="keyword">if</span> len(x) &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            res = res + x[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 你总是忘记特殊条件判断啊亲！！</span></span><br><span class="line">        <span class="comment"># 纵向扫描的正常操作</span></span><br><span class="line">         res=<span class="string">""</span></span><br><span class="line">         <span class="keyword">if</span> strs==[]:</span><br><span class="line">             <span class="keyword">return</span> res</span><br><span class="line">         <span class="keyword">if</span> len(strs)==<span class="number">1</span>:  <span class="comment"># 只有一个字母的情况</span></span><br><span class="line">             <span class="keyword">return</span> res+strs[<span class="number">0</span>]</span><br><span class="line">         <span class="comment"># 判断哪个字符最短</span></span><br><span class="line">         mins= min(len(strs[i]) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(strs)))</span><br><span class="line">         <span class="keyword">for</span> i <span class="keyword">in</span> range(mins): <span class="comment"># 对每个字符串遍历每一个字符</span></span><br><span class="line">             <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,len(strs)): <span class="comment"># 遍历整个字符串序列</span></span><br><span class="line">                 <span class="keyword">if</span> strs[j<span class="number">-1</span>][i]==strs[j][i]:</span><br><span class="line">                     <span class="keyword">continue</span></span><br><span class="line">                 <span class="keyword">break</span></span><br><span class="line">             <span class="keyword">if</span> strs[j<span class="number">-1</span>][i]==strs[j][i]:</span><br><span class="line">                 res+=strs[j][i]</span><br><span class="line">             <span class="keyword">else</span>:</span><br><span class="line">                 <span class="keyword">break</span></span><br><span class="line">         <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<p>评论区首条，xshura的评论，链接咋个没有，好像评论区的不给链接？？</p>
<hr>
<p>一道新题里边评论里出现的问题，虽然我没遇到，但是我也没有考虑到，所以记录一下：</p>
<p>在进行字符串拼接的时候：</p>
<p>res = res + string;的时候会开辟新的内存，所以导致内存超了。</p>
<p>而res += string的话相当于res.append(string)，直接在字符串末尾添加字符.</p>
<p>题比较简单，就不放上来了</p>
<p>参考评论区</p>
<hr>
<h4 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a><a href="https://leetcode-cn.com/problems/compare-version-numbers/" target="_blank" rel="noopener">165. 比较版本号</a></h4><p>比较两个版本号 <em>version1</em> 和 <em>version2</em>。<br> 如果 <code>version1 &gt; version2</code> 返回 <code>1</code>，如果 <code>version1 &lt; version2</code> 返回 <code>-1</code>， 除此之外返回 <code>0</code>。</p>
<p>你可以假设版本字符串非空，并且只包含数字和 <code>.</code> 字符。</p>
<p> <code>.</code> 字符不代表小数点，而是用于分隔数字序列。</p>
<p>例如，<code>2.5</code> 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。</p>
<p>你可以假设版本号的每一级的默认修订版号为 <code>0</code>。例如，版本号 <code>3.4</code> 的第一级（大版本）和第二级（小版本）修订号分别为 <code>3</code> 和 <code>4</code>。其第三级和第四级修订号均为 <code>0</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot;</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: version1 = &quot;1.0.1&quot;, version2 = &quot;1&quot;</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot;</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：version1 = &quot;1.01&quot;, version2 = &quot;1.001&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：忽略前导零，“01” 和 “001” 表示相同的数字 “1”。</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：version1 = &quot;1.0&quot;, version2 = &quot;1.0.0&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：version1 没有第三级修订号，这意味着它的第三级修订号默认为 “0”。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>版本字符串由以点 （<code>.</code>） 分隔的数字字符串组成。这个数字字符串<strong>可能</strong>有前导零。</li>
<li>版本字符串不以点开始或结束，并且其中不会有两个连续的点。</li>
</ol>
<p>仅作记录，对于python的包啥的还有漫漫长路</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compareVersion</span><span class="params">(self, version1, version2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type version1: str</span></span><br><span class="line"><span class="string">        :type version2: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 其实有想到用split，但是对于enumrate和zip打包实在还是不够熟练</span></span><br><span class="line">        <span class="comment"># code1基本上就是根据.进行切割，之后再转成int进行比较</span></span><br><span class="line">         <span class="keyword">for</span> x, y <span class="keyword">in</span> itertools.zip_longest(version1.split(<span class="string">"."</span>), version2.split(<span class="string">"."</span>), fillvalue=<span class="number">0</span>):</span><br><span class="line">             <span class="keyword">if</span> int(x) != int(y): <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> int(x) &gt; int(y) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># map() 会根据提供的函数对指定序列做映射。</span></span><br><span class="line">        <span class="comment"># code2第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表</span></span><br><span class="line">         v1,v2 = ([*map(int, v.split(<span class="string">'.'</span>))] <span class="keyword">for</span> v <span class="keyword">in</span> (version1, version2))</span><br><span class="line">         d = len(v2) - len(v1)</span><br><span class="line">         v1, v2 = v1 + [<span class="number">0</span>] * d, v2 + [<span class="number">0</span>] * -d</span><br><span class="line">         <span class="keyword">return</span> (v1 &gt; v2) - (v1 &lt; v2)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># code3其实还是看不懂代码，但是提交不上不是很懂，只有自己乱写写了</span></span><br><span class="line">        v1=version1.split(<span class="string">'.'</span>)</span><br><span class="line">        v2=version2.split(<span class="string">'.'</span>)</span><br><span class="line">        d=len(v2)-len(v1)</span><br><span class="line">        v1, v2 = v1 + [<span class="number">0</span>] * d, v2 + [<span class="number">0</span>] * -d</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(v1)):</span><br><span class="line">            <span class="keyword">if</span> int(v1[i])!=int(v2[i]):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> int(v1[i]) &gt; int(v2[i]) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="1160-拼写单词"><a href="#1160-拼写单词" class="headerlink" title="1160. 拼写单词"></a><a href="https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/" target="_blank" rel="noopener">1160. 拼写单词</a></h4><p>给你一份『词汇表』（字符串数组） <code>words</code> 和一张『字母表』（字符串） <code>chars</code>。</p>
<p>假如你可以用 <code>chars</code> 中的『字母』（字符）拼写出 <code>words</code> 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。</p>
<p>注意：每次拼写时，<code>chars</code> 中的每个字母都只能用一次。</p>
<p>返回词汇表 <code>words</code> 中你掌握的所有单词的 <strong>长度之和</strong>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;cat&quot;,&quot;bt&quot;,&quot;hat&quot;,&quot;tree&quot;], chars = &quot;atach&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释： </span><br><span class="line">可以形成字符串 &quot;cat&quot; 和 &quot;hat&quot;，所以答案是 3 + 3 = 6。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;hello&quot;,&quot;world&quot;,&quot;leetcode&quot;], chars = &quot;welldonehoneyr&quot;</span><br><span class="line">输出：10</span><br><span class="line">解释：</span><br><span class="line">可以形成字符串 &quot;hello&quot; 和 &quot;world&quot;，所以答案是 5 + 5 = 10。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= words.length &lt;= 1000</code></li>
<li><code>1 &lt;= words[i].length, chars.length &lt;= 100</code></li>
<li>所有字符串中都仅包含小写英文字母</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countCharacters</span><span class="params">(self, words, chars)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :type chars: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 注意 ：每次拼写时，chars 中的每个字母都只能用一次</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 学习一下写法</span></span><br><span class="line">        <span class="comment"># 第一是循环的写法</span></span><br><span class="line">        <span class="comment"># 第二是方法：采用判断count的方式，可以省去我自己写的多余的空间部分</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> chars:</span><br><span class="line">                <span class="keyword">if</span> w.count(i) &lt;= chars.count(i):</span><br><span class="line">                    flag=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    flag=<span class="number">0</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> flag==<span class="number">1</span>:</span><br><span class="line">                ans+=len(w)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 感觉很慢的方法，时间O(mn) 空间O(m)</span></span><br><span class="line">         res=<span class="number">0</span></span><br><span class="line">         <span class="keyword">for</span> i <span class="keyword">in</span> range(len(words)):</span><br><span class="line">             tag=<span class="number">0</span></span><br><span class="line">             chars_tmp=chars</span><br><span class="line">             <span class="keyword">for</span> j <span class="keyword">in</span> range(len(words[i])):</span><br><span class="line">                 <span class="keyword">if</span> words[i][j] <span class="keyword">in</span> chars_tmp:</span><br><span class="line">                     <span class="comment"># 好像删除只有用切片好一点</span></span><br><span class="line">                     ind=chars_tmp.find(words[i][j])</span><br><span class="line">                     chars_tmp=chars_tmp[:ind]+chars_tmp[ind+<span class="number">1</span>:]</span><br><span class="line">                 <span class="keyword">else</span>:</span><br><span class="line">                     tag=<span class="number">1</span></span><br><span class="line">             <span class="keyword">if</span> tag==<span class="number">0</span>:<span class="comment"># 这个单词可以掌握</span></span><br><span class="line">                 res+=len(words[i])</span><br><span class="line">         <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>参考评论首条</p>
<hr>
<h4 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71. 简化路径"></a><a href="https://leetcode-cn.com/problems/simplify-path/" target="_blank" rel="noopener">71. 简化路径</a></h4><p>以 Unix 风格给出一个文件的<strong>绝对路径</strong>，你需要简化它。或者换句话说，将其转换为规范路径。</p>
<p>在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：<a href="https://blog.csdn.net/u011327334/article/details/50355600" target="_blank" rel="noopener">Linux / Unix中的绝对路径 vs 相对路径</a></p>
<p>请注意，返回的规范路径必须始终以斜杠 <code>/</code> 开头，并且两个目录名之间必须只有一个斜杠 <code>/</code>。最后一个目录名（如果存在）<strong>不能</strong>以 <code>/</code> 结尾。此外，规范路径必须是表示绝对路径的<strong>最短</strong>字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;/home/&quot;</span><br><span class="line">输出：&quot;/home&quot;</span><br><span class="line">解释：注意，最后一个目录名后面没有斜杠。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;/../&quot;</span><br><span class="line">输出：&quot;/&quot;</span><br><span class="line">解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;/home//foo/&quot;</span><br><span class="line">输出：&quot;/home/foo&quot;</span><br><span class="line">解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;/a/./b/../../c/&quot;</span><br><span class="line">输出：&quot;/c&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;/a/../../b/../c//.//&quot;</span><br><span class="line">输出：&quot;/c&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 6：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;/a//b////c/d//././/..&quot;</span><br><span class="line">输出：&quot;/a/b/c&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这个我自己写的话就是用一个字符串的栈，每次输入的时候就判断其之前的所有情况：</p>
<ul>
<li>当输入为’.’：<ul>
<li>如果前边是’/‘：输入</li>
<li>如果前边是’.’：返回上一级目录</li>
<li>如果前边是其他：输入</li>
</ul>
</li>
<li><p>当输入为’/‘:</p>
<ul>
<li>如果前边是’/‘：continue</li>
<li>如果前边是’.’：删去’.’，且不写入’/‘直接continue</li>
<li>如果前边是其他：输入</li>
</ul>
</li>
</ul>
</li>
<li>这样判断下来呢整体来说是没有问题，除了逻辑复杂一点，再除了出题人…当做目录这种玩意操作通不过。。。。</li>
<li>看了下评论区的方法，觉得这个方法挺不错的，就放上来<ul>
<li>是直接将path通过/进行切分，之后对切下来的部分. .. 这些再进行判断</li>
<li>最后用join连接</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">simplifyPath</span><span class="params">(self, path)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type path: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 这绝了啊、、、、</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> path.split(<span class="string">'/'</span>):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">''</span>, <span class="string">'.'</span>, <span class="string">'..'</span>]:<span class="comment"># ''是'//'分割下来，可以不用管,'.'也可以不用管</span></span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="string">'..'</span> <span class="keyword">and</span> stack:</span><br><span class="line">                stack.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/"</span> + <span class="string">"/"</span>.join(stack)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 确实应该用栈 我的方法</span></span><br><span class="line">         res=<span class="string">""</span></span><br><span class="line">         <span class="keyword">if</span> path==<span class="string">'/...'</span>:</span><br><span class="line">             <span class="keyword">return</span> <span class="string">"/..."</span></span><br><span class="line">         <span class="comment"># 这个...我没搞出来，====</span></span><br><span class="line">         <span class="comment"># path.replace("...","a")</span></span><br><span class="line">         <span class="keyword">for</span> i <span class="keyword">in</span> range (len(path)):</span><br><span class="line">             print(res)</span><br><span class="line">             <span class="keyword">if</span> res==<span class="string">""</span>:</span><br><span class="line">                 res+=path[i]  <span class="comment"># 先把/放进去</span></span><br><span class="line">                 <span class="keyword">continue</span></span><br><span class="line">             <span class="keyword">if</span> path[i]==<span class="string">'/'</span>:</span><br><span class="line">                 <span class="keyword">if</span> res[<span class="number">-1</span>]==<span class="string">'.'</span>:</span><br><span class="line">                     res=res[:<span class="number">-1</span>]</span><br><span class="line">                     <span class="keyword">continue</span></span><br><span class="line">                 <span class="keyword">elif</span> res[<span class="number">-1</span>]==<span class="string">'/'</span>:</span><br><span class="line">                     <span class="keyword">continue</span></span><br><span class="line">                 res+=path[i]</span><br><span class="line">             <span class="keyword">elif</span> path[i]==<span class="string">'.'</span>: <span class="comment"># .前边好像只能是.或者/</span></span><br><span class="line">                 <span class="keyword">if</span> res[<span class="number">-1</span>]==<span class="string">'.'</span> <span class="keyword">and</span> path[i+<span class="number">1</span>]!=<span class="string">'.'</span>:<span class="comment"># 返回上一级目录</span></span><br><span class="line">                     res=res[:<span class="number">-1</span>]<span class="comment">#.</span></span><br><span class="line">                     <span class="keyword">if</span> res==<span class="string">'/'</span>:</span><br><span class="line">                         <span class="keyword">continue</span></span><br><span class="line">                     <span class="keyword">else</span>:</span><br><span class="line">                         res=res[:<span class="number">-1</span>] <span class="comment"># /</span></span><br><span class="line">                         <span class="keyword">while</span> res[<span class="number">-1</span>]!=<span class="string">'/'</span>:</span><br><span class="line">                             res=res[:<span class="number">-1</span>]</span><br><span class="line">                     <span class="keyword">continue</span></span><br><span class="line">                 <span class="keyword">if</span> res[<span class="number">-1</span>]==<span class="string">'.'</span> <span class="keyword">and</span> path[i+<span class="number">1</span>]==<span class="string">'.'</span>:<span class="comment"># 视为目录</span></span><br><span class="line">                     res+=path[i]</span><br><span class="line">                     <span class="keyword">continue</span></span><br><span class="line">                 <span class="keyword">elif</span> res[<span class="number">-1</span>]==<span class="string">'/'</span>:</span><br><span class="line">                     res+=path[i]</span><br><span class="line">                     <span class="keyword">continue</span></span><br><span class="line">             <span class="keyword">else</span>:</span><br><span class="line">                 res+=path[i]</span><br><span class="line">         <span class="keyword">if</span> res!=<span class="string">'/'</span> <span class="keyword">and</span> res[<span class="number">-1</span>]==<span class="string">'/'</span>:</span><br><span class="line">             res=res[:<span class="number">-1</span>]</span><br><span class="line">         res=res.replace(<span class="string">"."</span>,<span class="string">""</span>)</span><br><span class="line">         <span class="keyword">return</span> res</span><br><span class="line"><span class="comment">#参考：评论区</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409. 最长回文串"></a><a href="https://leetcode-cn.com/problems/longest-palindrome/" target="_blank" rel="noopener">409. 最长回文串</a></h4><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p>
<p>在构造过程中，请注意区分大小写。比如 <code>&quot;Aa&quot;</code> 不能当做一个回文字符串。</p>
<p><strong>注意:</strong><br> 假设字符串的长度不会超过 1010。</p>
<p><strong>示例 1:</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;abccccdd&quot;</span><br><span class="line">输出:</span><br><span class="line">7</span><br><span class="line">解释:</span><br><span class="line">我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。</span><br></pre></td></tr></table></figure>
<p>我的做法比较基础，当然也是因为不知道可以count，就是先构造了一个字典，来存储每个数的计数，然后通过正向的：偶数个的数+（奇数个的数-1）+1（如果有奇数个的数）</p>
<p>后来看了评论之后发现用逆向的，从字符串s 减下来这样会更简单一点：字符串s的长度-奇数个的字母的个数+1（如果至少一个奇数可以放中间）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 用总长度减的话，需要减去不能加上去的奇数个的数</span></span><br><span class="line">        <span class="comment"># 确实这样反过来要简单一些</span></span><br><span class="line">        <span class="comment"># 但是count 是不是有个遍历，算成n^2了？</span></span><br><span class="line">        <span class="comment"># 注意set是无序不重复数组</span></span><br><span class="line">        ys=sum([s.count(i)%<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> set(s)])<span class="number">-1</span><span class="comment"># 不能加上去的奇数个的数</span></span><br><span class="line">        <span class="keyword">return</span> len(s)-max(<span class="number">0</span>,ys)  <span class="comment"># -1是因为中间可以放一个，与0 比大小是因为可能没有中间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 有点想用字典，但是字典怎么用，emmm我查一下</span></span><br><span class="line">         lens=<span class="number">0</span></span><br><span class="line">         dict=&#123;&#125;</span><br><span class="line">         tag=<span class="number">0</span></span><br><span class="line">         <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">             <span class="keyword">if</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> dict: <span class="comment"># 不在字典里就写入</span></span><br><span class="line">                 dict[s[i]] = <span class="number">1</span></span><br><span class="line">             <span class="keyword">else</span>:<span class="comment"># 如果在字典里边了，就加一</span></span><br><span class="line">                 dict[s[i]] += <span class="number">1</span></span><br><span class="line">         print(dict)<span class="comment"># 很好很好跟我想的一下</span></span><br><span class="line">         <span class="keyword">for</span> i <span class="keyword">in</span> dict:</span><br><span class="line">             <span class="comment"># print(dict[i])</span></span><br><span class="line">             <span class="keyword">if</span> dict[i]%<span class="number">2</span>==<span class="number">0</span>:<span class="comment"># 如果是偶数个</span></span><br><span class="line">                 <span class="comment"># print("aaa")</span></span><br><span class="line">                 lens+=dict[i]</span><br><span class="line">             <span class="keyword">elif</span> tag==<span class="number">0</span>:<span class="comment"># 如果是奇数个,第一次需要加上中间的，所以全加</span></span><br><span class="line">                 lens=lens+ dict[i]</span><br><span class="line">                 tag=<span class="number">1</span> <span class="comment"># 中间的已经加上了</span></span><br><span class="line">             <span class="keyword">else</span>:</span><br><span class="line">                 lens=lens+ dict[i]<span class="number">-1</span>  <span class="comment"># 后边就只能就偶数个了</span></span><br><span class="line">         <span class="keyword">return</span> lens</span><br></pre></td></tr></table></figure>
<p>参考：评论区</p>
<hr>
<h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></h4><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure>
<p>写了这么多了中等题还是不会做啊，脑仁疼</p>
<p>大佬说暴力匹配是基础，动态规划必须掌握，中心扩散要会写，Manacher （马拉车？？）算法了解</p>
<p>基本copy自题解区 liweiwei1419—<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/</a></p>
<h5 id="暴力匹配-时间-O-N-3-空间-O-1"><a href="#暴力匹配-时间-O-N-3-空间-O-1" class="headerlink" title="暴力匹配   时间$O(N^3)$ 空间$O(1)$"></a><strong>暴力匹配</strong>   时间$O(N^3)$ 空间$O(1)$</h5><p>很直接的思路，有想到，但是感觉太复杂了会超时间，所以就没有写</p>
<p>但其实代码还是挺清晰的，不过确实会超时</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 暴力匹配（超时）</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># 特例判断</span></span><br><span class="line">        size = len(s)</span><br><span class="line">        <span class="keyword">if</span> size &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        res = s[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 枚举所有长度大于等于 2 的子串</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, size):</span><br><span class="line">                <span class="comment"># 在长度大于当前长度且是回文串时</span></span><br><span class="line">                <span class="keyword">if</span> j - i + <span class="number">1</span> &gt; max_len <span class="keyword">and</span> self.__valid(s, i, j):</span><br><span class="line">                    max_len = j - i + <span class="number">1</span></span><br><span class="line">                    res = s[i:j + <span class="number">1</span>]<span class="comment"># 保存</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__valid</span><span class="params">(self, s, left, right)</span>:</span></span><br><span class="line">        <span class="comment"># 验证子串 s[left, right] 是否为回文串</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> s[left] != s[right]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h5 id="动态规划-时间-O-N-2-空间-O-N-2-：本质是用空间换取时间"><a href="#动态规划-时间-O-N-2-空间-O-N-2-：本质是用空间换取时间" class="headerlink" title="动态规划     时间 $O(N^2)$ 空间  $O(N^2)$  ：本质是用空间换取时间"></a><strong>动态规划     时间 $O(N^2)$ 空间  $O(N^2)$ </strong> ：本质是用空间换取时间</h5><p>大佬给出来的动态规划的整理：</p>
<p><img src="/2020/02/22/leetcode/leetcode-笔记/「动态规划」问题的思考方向.png" alt="「动态规划」问题的思考方向"></p>
<p>1、状态</p>
<p>2、状态转移方程（核心、难点）</p>
<p>动态规划的本质就是打表格，从一个小规模问题出发，逐步得到大问题的解，并记录过程。动态规划依然是“空间换时间”思想的体现。</p>
<p>3、初始化</p>
<p>角度 1：直接从状态的语义出发；</p>
<p>角度 2：如果状态的语义不好思考，就考虑“状态转移方程”的边界需要什么样初始化的条件；</p>
<p>角度 3：从“状态转移方程”方程的下标看是否需要多设置一行、一列表示“哨兵”，这样可以避免一些边界的讨论，使得代码变得比较短。</p>
<p>4、输出</p>
<p>有些时候是最后一个状态，有些时候可能会综合所有计算过的状态。</p>
<p>5、状态压缩</p>
<p>在状态空间非常庞大的时候（处理海量数据），此时空间不够用，就必须状态压缩。</p>
<p>因此本题中：</p>
<h6 id="第-1-步：定义状态"><a href="#第-1-步：定义状态" class="headerlink" title="第 1 步：定义状态"></a>第 1 步：定义状态</h6><ul>
<li>我刚一开始想到的状态就是直接定义最长的回文子串，但是在转移方程的时候，最长就不好体现出来了</li>
<li><code>dp[i][j]</code> 表示子串 <code>s[i, j]</code> <strong>是否为回文子串</strong>。</li>
</ul>
<h6 id="第-2-步：思考状态转移方程"><a href="#第-2-步：思考状态转移方程" class="headerlink" title="第 2 步：思考状态转移方程"></a>第 2 步：思考状态转移方程</h6><ul>
<li>这一步在做分类讨论（根据头尾字符是否相等），根据上面的分析得到：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = (s[i] == s[j]) <span class="keyword">and</span> dp[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h6 id="第-3-步：考虑初始化"><a href="#第-3-步：考虑初始化" class="headerlink" title="第 3 步：考虑初始化"></a>第 3 步：考虑初始化</h6><ul>
<li><code>dp[i][i] = 1</code> 。</li>
<li>表格中有一半三角可以不用考虑</li>
</ul>
<h6 id="第-4-步：考虑输出"><a href="#第-4-步：考虑输出" class="headerlink" title="第 4 步：考虑输出"></a>第 4 步：考虑输出</h6><ul>
<li>只要一得到 <code>dp[i][j] = true</code>，就记录子串的长度和起始位置，没有必要截取，因为截取字符串也要消耗性能，记录此时的回文子串的“起始位置”和“回文长度”即可。</li>
</ul>
<h6 id="第-5-步：考虑状态是否可以压缩"><a href="#第-5-步：考虑状态是否可以压缩" class="headerlink" title="第 5 步：考虑状态是否可以压缩"></a>第 5 步：考虑状态是否可以压缩</h6><p>因为在填表的过程中，只参考了左下方的数值。事实上可以压缩，但会增加一些判断语句，增加代码编写和理解的难度，丢失可读性。在这里不做状态压缩。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        size = len(s)</span><br><span class="line">        <span class="keyword">if</span> size &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="comment"># 初始化-表格默认值FALSE——不是回文串</span></span><br><span class="line">        dp = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(size)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(size)]</span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            dp[i][i] = <span class="keyword">True</span> <span class="comment"># 初始化-对角线是回文串</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, size):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, j):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    <span class="keyword">if</span> j - i &lt; <span class="number">3</span>: <span class="comment"># 当字符串长度小于等于3且s[i]==s[j]时,可以直接判断为True</span></span><br><span class="line">                        dp[i][j] = <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">else</span>: <span class="comment"># 若字符串长度大于3，则需要参考剪头尾之后是否为回文串</span></span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:<span class="comment"># 如果不等，肯定不是回文串</span></span><br><span class="line">                    dp[i][j] = <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">if</span> dp[i][j]:<span class="comment"># 判断为回文串且长度大于max 则保存起始位置和长度</span></span><br><span class="line">                    cur_len = j - i + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> cur_len &gt; max_len:</span><br><span class="line">                        max_len = cur_len</span><br><span class="line">                        start = i</span><br><span class="line">        <span class="keyword">return</span> s[start:start + max_len]</span><br></pre></td></tr></table></figure>
<h5 id="中心扩散法-时间-O-N-2-空间-O-1"><a href="#中心扩散法-时间-O-N-2-空间-O-1" class="headerlink" title="中心扩散法   时间 $O(N^2)$ 空间  $O(1)$"></a><strong>中心扩散法</strong>   时间 $O(N^2)$ 空间  $O(1)$</h5><ul>
<li><p>遍历每一个索引，以这个索引为中心，利用“回文串”中心对称的特点，往两边扩散，看最多能扩散多远。</p>
</li>
<li><p>枚举“中心位置”时间复杂度为 O(N)，从“中心位置”扩散得到“回文子串”的时间复杂度为 O(N)，因此时间复杂度可以降到 O(N^2))。</p>
</li>
<li><p>在这里要注意一个细节：回文串在长度为奇数和偶数的时候，“回文中心”的形式是不一样的。</p>
<ul>
<li>奇数回文串的“中心”是一个具体的字符，例如：回文串 <code>&quot;aba&quot;</code> 的中心是字符 <code>&quot;b&quot;</code>；</li>
<li>偶数回文串的“中心”是位于中间的两个字符的“空隙”，例如：回文串 <code>&quot;abba&quot;</code> 的中心是两个 <code>&quot;b&quot;</code> 中间的那个“空隙”。 </li>
</ul>
</li>
<li><p>看一下一个字符串可能的回文子串的中心在哪里？</p>
</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/3c4ca880f2dd7463e15ddf7bbd59e2f7d11434b7dbc69b55893660012726ee88.jpg" alt="图 2：枚举可能的所有回文中心"></p>
<ul>
<li>我们可以设计一个方法，兼容以上两种情况：<ul>
<li>1、如果传入重合的索引编码，进行中心扩散，此时得到的回文子串的长度是奇数；</li>
<li>2、如果传入相邻的索引编码，进行中心扩散，此时得到的回文子串的长度是偶数。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        size = len(s)</span><br><span class="line">        <span class="keyword">if</span> size &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="comment"># 至少是 1</span></span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        res = s[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            palindrome_odd, odd_len = self.__center_spread(s, size, i, i)<span class="comment">#奇数</span></span><br><span class="line">            palindrome_even, even_len = self.__center_spread(s, size, i, i + <span class="number">1</span>)<span class="comment">#偶数</span></span><br><span class="line">            <span class="comment"># 当前找到的最长回文子串</span></span><br><span class="line">            cur_max_sub = palindrome_odd <span class="keyword">if</span> odd_len &gt;= even_len <span class="keyword">else</span> palindrome_even</span><br><span class="line">            <span class="keyword">if</span> len(cur_max_sub) &gt; max_len:</span><br><span class="line">                max_len = len(cur_max_sub)</span><br><span class="line">                res = cur_max_sub</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__center_spread</span><span class="params">(self, s, size, left, right)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        left = right 的时候，此时回文中心是一个字符，回文串的长度是奇数</span></span><br><span class="line"><span class="string">        right = left + 1 的时候，此时回文中心是一个空隙，回文串的长度是偶数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i = left</span><br><span class="line">        j = right</span><br><span class="line">        <span class="comment"># 在满足回文的条件（相等）的情况下，往两边扩散</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; size <span class="keyword">and</span> s[i] == s[j]:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[i + <span class="number">1</span>:j], j - i - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h5 id="Manacher-算法时间-O-N-空间-O-N"><a href="#Manacher-算法时间-O-N-空间-O-N" class="headerlink" title="Manacher 算法时间 $O(N)$ 空间  $O(N)$  "></a><strong>Manacher 算法时间 $O(N)$ 空间  $O(N)$  </strong></h5><p>可以很好地解决“最长回文子串”问题，时间复杂度为 <em>O</em>(<em>N</em>)。</p>
<h6 id="第-1-步：对原始字符串进行预处理（添加分隔符）"><a href="#第-1-步：对原始字符串进行预处理（添加分隔符）" class="headerlink" title="第 1 步：对原始字符串进行预处理（添加分隔符）"></a>第 1 步：对原始字符串进行预处理（添加分隔符）</h6><ul>
<li><p>首先在字符串的首尾、相邻的字符中插入分隔符，例如 <code>&quot;babad&quot;</code> 添加分隔符 <code>&quot;#&quot;</code> 以后得到 <code>&quot;#b#a#b#a#d#&quot;</code>。</p>
</li>
<li><p>对这一点有如下说明：</p>
<ul>
<li>分隔符是一个字符，种类也只有一个，并且这个字符一定不能是原始字符串中出现过的字符；</li>
<li>加入了分隔符以后，使得“间隙”有了具体的位置，方便后续的讨论，并且<strong>新字符串中的任意一个回文子串在原始字符串中的一定能找到唯一的一个回文子串与之对应</strong>，因此对新字符串的回文子串的研究就能得到原始字符串的回文子串；</li>
<li>新字符串的回文子串的长度一定是奇数；（、、、这有点厉害了）</li>
<li>新字符串的回文子串一定以分隔符作为两边的边界，因此分隔符起到“哨兵”的作用。</li>
</ul>
</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/d9546795e5c73d06b7c77645aef92413f794b3850a62492682a46eb00c9ee711.jpg" alt="图 3：原始字符串与新字符串的对应关系"></p>
<h6 id="第-2-步：计算辅助数组-p"><a href="#第-2-步：计算辅助数组-p" class="headerlink" title="第 2 步：计算辅助数组 p"></a>第 2 步：计算辅助数组 p</h6><ul>
<li>辅助数组 <code>p</code> 记录了新字符串中以每个字符为中心的回文子串的信息。</li>
<li>手动的计算方法仍然是“中心扩散法”，此时记录以当前字符为中心，向左右两边同时扩散，记录能够扩散的最大步数。</li>
<li>以字符串 <code>&quot;abbabb&quot;</code> 为例，说明如何手动计算得到辅助数组 <code>p</code> ，我们要填的就是下面这张表。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>char</strong></th>
<th><strong>#</strong></th>
<th><strong>a</strong></th>
<th><strong>#</strong></th>
<th><strong>b</strong></th>
<th><strong>#</strong></th>
<th><strong>b</strong></th>
<th><strong>#</strong></th>
<th><strong>a</strong></th>
<th><strong>#</strong></th>
<th><strong>b</strong></th>
<th><strong>#</strong></th>
<th><strong>b</strong></th>
<th><strong>#</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>index</strong></td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>12</td>
</tr>
<tr>
<td><strong>p</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li><p>第 1 行数组 <code>char</code> ：原始字符串<strong>加上分隔符以后</strong>的每个字符。</p>
</li>
<li><p>第 2 行数组 <code>index</code> ：这个数组是新字符串的索引数组，它的值是从 000 开始的索引编号。</p>
</li>
<li><p>首先 <code>p[0]</code>=0，扩散一步即到边界。同理<code>p[1]</code> =1，<code>p[2]</code>=0 ，<code>p[3]</code>=1， <code>p[4]</code>=4。（中心对称的步数）</p>
</li>
<li><p>剩下的部分如下：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>char</strong></th>
<th><strong>#</strong></th>
<th><strong>a</strong></th>
<th><strong>#</strong></th>
<th><strong>b</strong></th>
<th><strong>#</strong></th>
<th><strong>b</strong></th>
<th><strong>#</strong></th>
<th><strong>a</strong></th>
<th><strong>#</strong></th>
<th><strong>b</strong></th>
<th><strong>#</strong></th>
<th><strong>b</strong></th>
<th><strong>#</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>index</strong></td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>12</td>
</tr>
<tr>
<td><strong>p</strong></td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>4</td>
<td>1</td>
<td>0</td>
<td>5</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p><strong>说明</strong>：有些资料将辅助数组 <code>p</code> 定义为回文半径数组，即 <code>p[i]</code> 记录了以新字符串第 <code>i</code> 个字符为中心的回文字符串的半径（包括第 <code>i</code> 个字符），与我们这里定义的辅助数组 <code>p</code> 有一个字符的偏差，本质上是一样的。</p>
<h6 id="结论：辅助数组-p-的最大值就是“最长回文子串”的长度。"><a href="#结论：辅助数组-p-的最大值就是“最长回文子串”的长度。" class="headerlink" title="结论：辅助数组 p 的最大值就是“最长回文子串”的长度。"></a>结论：辅助数组 <code>p</code> 的最大值就是“最长回文子串”的长度。</h6><ul>
<li><p>简单说明一下：</p>
</li>
<li><p>如果新回文子串的中心是一个字符，那么原始回文子串的中心也是一个字符，“先分隔符，后字符”。<strong>因为最后一定以分隔符结尾，还要计算一个，正好这个就可以把原始回文子串的中心算进去</strong>；</p>
<p><img src="https://pic.leetcode-cn.com/4ba4319f13bee429bb95ba119dcaefe71c9644bcf9e9be3ba2637d13fcccd3d6.jpg" alt="图 4：理解辅助数组的数值与原始字符串回文子串的等价性-1" style="zoom:50%;"></p>
</li>
<li><p>如果新回文子串的中心是 <code>#</code>，那么原始回文子串的中心就是一个“空隙”。“先字符，后分隔符”</p>
<p><img src="https://pic.leetcode-cn.com/05e76869add71c1cbf396bb89ee5ad7f560cc6c5e60926ceaef00a3bbc32c9e4.jpg" alt="图 4：理解辅助数组的数值与原始字符串回文子串的等价性-2" style="zoom: 33%;"></p>
</li>
</ul>
<h6 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h6><ul>
<li>对于遍历的方法来计算P，其实和中心扩散差不多，时间也在O(n^2)，因此对p的计算方法进行了改进</li>
<li><p>对新字符串每一个位置进行中心扩散，会导致原始字符串的每一个字符被访问多次，计算机科学家 Manacher 就改进了这种算法，使得在填写新的辅助数组 <code>p</code> 的值的时候，能够参考已经填写过的辅助数组 <code>p</code> 的值，使得新字符串每个字符只访问了一次，整体时间复杂度由 O(N^2)改进到 O(N)。</p>
</li>
<li><p>具体做法是：在遍历的过程中，除了循环变量 <code>i</code> 以外，我们还需要记录两个变量，它们是 <code>maxRight</code> 和 <code>center</code> ，它们分别的含义如下：</p>
<ul>
<li><p><code>maxRight</code>：记录当前向右扩展的最远边界，即从开始到现在使用“中心扩散法”能得到的回文子串能延伸到的最右端的位置 。对于 <code>maxRight</code> 我们说明 3 点：</p>
<ul>
<li>“向右最远”是在计算辅助数组 <code>p</code> 的过程中，向右边扩散能走的索引最大的位置，注意：得到一个 <code>maxRight</code> 所对应的回文子串，并不一定是当前得到的“最长回文子串”，很可能的一种情况是，某个回文子串可能比较短，但是它正好在整个字符串比较靠后的位置；</li>
<li><code>maxRight</code> 的下一个位置可能是被程序看到的，停止的原因有 2 点：（1）左边界不能扩散，导致右边界受限制也不能扩散，<code>maxRight</code> 的下一个位置看不到；（2）正是因为看到了 <code>maxRight</code> 的下一个位置，导致 <code>maxRight</code> 不能继续扩散。</li>
<li>为什么 <code>maxRight</code> 很重要？因为扫描是从左向右进行的， <code>maxRight</code> 能够提供的信息最多，它是一个重要的分类讨论的标准，因此我们需要一个变量记录它。</li>
</ul>
</li>
<li><p><code>center</code>：<code>center</code> 是与 <code>maxRight</code> 相关的一个变量，它是上述 <code>maxRight</code> 的回文中心的索引值。对于 <code>center</code> 的说明如下：</p>
<ul>
<li><code>center</code> 的形式化定义：<br>$$<br>center = argmax {x + p[x]  \; | \;  0 \leq x&lt; i }<br>$$</li>
</ul>
</li>
</ul>
</li>
<li><p><code>maxRight</code> 与 <code>center</code> 是一一对应的关系，即一个  <code>center</code> 的值唯一对应了一个 <code>maxRight</code> 的值；因此 <strong><code>maxRight</code> 与 <code>center</code> 必须要同时更新</strong>。</p>
</li>
</ul>
<p>下面的讨论就根据循环变量 <code>i</code> 与 <code>maxRight</code> 的关系展开讨论：</p>
<ul>
<li><p>情况 1：当 <code>i &gt;= maxRight</code> 的时候，这就是一开始，以及刚刚把一个回文子串扫描完的情况，此时只能够根据“中心扩散法”一个一个扫描，逐渐扩大 <code>maxRight</code>；</p>
</li>
<li><p>情况 2：当 <code>i &lt; maxRight</code> 的时候，根据新字符的回文子串的性质，循环变量关于 <code>center</code> 对称的那个索引（记为 <code>mirror</code>）的 <code>p</code> 值就很重要。</p>
<ul>
<li>我们先看 <code>mirror</code> 的值是多少，因为 <code>center</code> 是中心，<code>i</code> 和 <code>mirror</code> 关于 <code>center</code> 中心对称，因此 <code>(mirror + i) / 2 = center</code> ，所以 <code>mirror = 2 * center - i</code>。</li>
<li>根据 <code>p[mirror]</code> 的数值从小到大，具体可以分为如下 3 种情况：<ul>
<li>情况 2（1）：<code>p[mirror]</code> 的数值比较小，不超过 <code>maxRight - i</code>。</li>
<li>说明：<code>maxRight - i</code> 的值，就是从 <code>i</code> 关于 <code>center</code> 的镜像点开始向左走（不包括它自己），到 <code>maxRight</code> 关于 <code>center</code> 的镜像点的步数</li>
<li><img src="https://pic.leetcode-cn.com/1fc56a2ecb6b67ccb5262b5cc3cfcff3041fdc0c6cd8cb0c329ef869644253a4.jpg" alt="图 5：Manacher 算法分类讨论情况 2（1）"></li>
<li>从图上可以看出，由于“以 <code>center</code> 为中心的回文子串”的对称性，导致了“以 <code>i</code> 为中心的回文子串”与“以 <code>center</code> 为中心的回文子串”也具有对称性，“以 <code>i</code> 为中心的回文子串”与“以 <code>center</code> 为中心的回文子串”不能再扩散了，此时，直接把数值抄过来即可，即 <code>p[i] = p[mirror]</code>。</li>
<li>情况 2（2）：<code>p[mirror]</code> 的数值恰好等于 <code>maxRight - i</code>。</li>
<li><img src="https://pic.leetcode-cn.com/74627724154804d8aa7062d1026ffeffa9f6202c1afb38603b91f7eb83eaec17.jpg" alt="图 5：Manacher 算法分类讨论情况 2（2）"></li>
<li>说明：仍然是依据“以 <code>center</code> 为中心的回文子串”的对称性，导致了“以 <code>i</code> 为中心的回文子串”与“以 <code>center</code> 为中心的回文子串”也具有对称性。</li>
<li>1.因为靠左边的 <code>f</code> 与靠右边的 <code>g</code> 的原因，导致“以 <code>center</code> 为中心的回文子串”不能继续扩散；</li>
<li>2.但是“以 <code>i</code> 为中心的回文子串” 还可以继续扩散。</li>
<li>因此，可以先把 <code>p[mirror]</code> 的值抄过来，然后继续“中心扩散法”，继续增加 <code>maxRight</code>。</li>
<li>情况 2（3）：<code>p[mirror]</code> 的数值大于 <code>maxRight - i</code>。</li>
<li><img src="https://pic.leetcode-cn.com/73ec2e14a7501999ccd6e60c77bd08415ccdf36fc6da4ab2f29311735a594e66.jpg" alt="图 5：Manacher 算法分类讨论情况 2（3）"></li>
<li>说明：仍然是依据“以 <code>center</code> 为中心的回文子串”的对称性，导致了“以 <code>i</code> 为中心的回文子串”与“以 <code>center</code> 为中心的回文子串”也具有对称性。<br>下面证明，<code>p[i] = maxRight - i</code> ，证明的方法还是利用三个回文子串的对称性。</li>
<li><img src="https://pic.leetcode-cn.com/d404aff63ecd764aaa70e6bb961a7e4286b8b2afdb6b4ce4bf696fb8eeb55086.jpg" alt="图 5：Manacher 算法分类讨论情况 2（3）的证明"></li>
<li>① 由于“以 <code>center</code> 为中心的回文子串”的对称性， 黄色箭头对应的字符 <code>c</code> 和 <code>e</code> 一定不相等；</li>
<li>② 由于“以 <code>mirror</code> 为中心的回文子串”的对称性， 绿色箭头对应的字符 <code>c</code> 和 <code>c</code> 一定相等；</li>
<li>③ 又由于“以 <code>center</code> 为中心的回文子串”的对称性， 蓝色箭头对应的字符 <code>c</code> 和 <code>c</code> 一定相等；</li>
<li>推出“以 <code>i</code> 为中心的回文子串”的对称性，  红色箭头对应的字符 <code>c</code> 和 <code>e</code> 一定不相等。</li>
<li>因此，<code>p[i] = maxRight - i</code>，不可能再大。上面是因为我画的图，可能看的朋友会觉得理所当然。事实上，可以使用反证法证明：</li>
<li>如果“以 <code>i</code> 为中心的回文子串” 再向两边扩散的两个字符 <code>c</code> 和 <code>e</code> 相等，就能够推出黄色、绿色、蓝色、红色箭头所指向的 8 个变量的值都相等，此时“以 <code>center</code> 为中心的回文子串” 就可以再同时向左边和右边扩散 111 格，与 <code>maxRight</code> 的最大性矛盾。</li>
<li>综合以上 3 种情况，当 <code>i &lt; maxRight</code> 的时候，<code>p[i]</code> 可以参考 <code>p[mirror]</code> 的信息，以 <code>maxRight - i</code> 作为参考标准，<code>p[i]</code> 的值应该是保守的，即二者之中较小的那个值：</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p[i] = min(maxRight - i, p[mirror]);</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># Manacher 算法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># 特判</span></span><br><span class="line">        size = len(s)</span><br><span class="line">        <span class="keyword">if</span> size &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 得到预处理字符串</span></span><br><span class="line">        t = <span class="string">"#"</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            t += s[i]</span><br><span class="line">            t += <span class="string">"#"</span></span><br><span class="line">        <span class="comment"># 新字符串的长度</span></span><br><span class="line">        t_len = <span class="number">2</span> * size + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 数组 p 记录了扫描过的回文子串的信息</span></span><br><span class="line">        p = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(t_len)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 双指针，它们是一一对应的，须同时更新</span></span><br><span class="line">        max_right = <span class="number">0</span></span><br><span class="line">        center = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当前遍历的中心最大扩散步数，其值等于原始字符串的最长回文子串的长度</span></span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 原始字符串的最长回文子串的起始位置，与 max_len 必须同时更新</span></span><br><span class="line">        start = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(t_len):</span><br><span class="line">            <span class="keyword">if</span> i &lt; max_right:</span><br><span class="line">                mirror = <span class="number">2</span> * center - i</span><br><span class="line">                <span class="comment"># 这一行代码是 Manacher 算法的关键所在，要结合图形来理解</span></span><br><span class="line">                p[i] = min(max_right - i, p[mirror])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 下一次尝试扩散的左右起点，能扩散的步数直接加到 p[i] 中</span></span><br><span class="line">            left = i - (<span class="number">1</span> + p[i])</span><br><span class="line">            right = i + (<span class="number">1</span> + p[i])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># left &gt;= 0 and right &lt; t_len 保证不越界</span></span><br><span class="line">            <span class="comment"># t[left] == t[right] 表示可以扩散 1 次</span></span><br><span class="line">            <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; t_len <span class="keyword">and</span> t[left] == t[right]:</span><br><span class="line">                p[i] += <span class="number">1</span></span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 根据 max_right 的定义，它是遍历过的 i 的 i + p[i] 的最大者</span></span><br><span class="line">            <span class="comment"># 如果 max_right 的值越大，进入上面 i &lt; max_right 的判断的可能性就越大，这样就可以重复利用之前判断过的回文信息了</span></span><br><span class="line">            <span class="keyword">if</span> i + p[i] &gt; max_right:</span><br><span class="line">                <span class="comment"># max_right 和 center 需要同时更新</span></span><br><span class="line">                max_right = i + p[i]</span><br><span class="line">                center = i</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> p[i] &gt; max_len:</span><br><span class="line">                <span class="comment"># 记录最长回文子串的长度和相应它在原始字符串中的起点</span></span><br><span class="line">                max_len = p[i]</span><br><span class="line">                start = (i - max_len) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> s[start: start + max_len]</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="面试题40-最小的k个数"><a href="#面试题40-最小的k个数" class="headerlink" title="面试题40. 最小的k个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">面试题40. 最小的k个数</a></h4><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [3,2,1], k = 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [0,1,2,1], k = 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>0 &lt;= k &lt;= arr.length &lt;= 10000</code></li>
<li><code>0 &lt;= arr[i] &lt;= 10000</code></li>
</ul>
<p>快排都可以达到期望O(n)（下次碰到再写堆排序吧、、、）</p>
<p>注意排序的写法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 最简单的方法用排序 O(n logn)</span></span><br><span class="line">        <span class="comment"># 但是排序这个东西，是不是还是应该自己写。。。</span></span><br><span class="line">        <span class="comment"># arr.sort()</span></span><br><span class="line">        <span class="comment"># return arr[:k]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 看了评论说sort直接凉凉，那还是算了吧，写个排序吧、、、</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 快排</span></span><br><span class="line">        <span class="comment"># 注意找前K大/前K小问题不需要对整个数组进行O(NlogN)的排序！</span></span><br><span class="line">        <span class="comment"># 例如本题，直接通过快排切分排好第K小的数（下标为K-1），那么它左边的数就是比它小的另外K-1个数啦～</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(arr, left ,right)</span>:</span><span class="comment"># 一次快排</span></span><br><span class="line">            pivot = arr[left]</span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[right] &gt; pivot:<span class="comment"># 先减再加</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                arr[left] = arr[right]</span><br><span class="line">                <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[left] &lt;= pivot:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                arr[right] = arr[left]</span><br><span class="line">            arr[left] = pivot</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quickSearch</span><span class="params">(nums,low, high,k)</span>:</span></span><br><span class="line">            <span class="comment"># // 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；</span></span><br><span class="line">            j = partition(nums, low, high)</span><br><span class="line">            <span class="keyword">if</span> (j == k):</span><br><span class="line">                <span class="keyword">return</span> nums[:j+<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># // 否则根据下标j与k的大小关系来决定继续切分左段还是右段。</span></span><br><span class="line">            <span class="keyword">return</span> quickSearch(nums, low, j - <span class="number">1</span>, k) <span class="keyword">if</span> j &gt; k <span class="keyword">else</span> quickSearch(nums, j + <span class="number">1</span>, high, k)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> <span class="keyword">or</span> len(arr) == <span class="number">0</span>):  <span class="comment"># 特例判断</span></span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># // 最后一个参数表示我们要找的是下标为k-1的数</span></span><br><span class="line">        <span class="keyword">return</span> quickSearch(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>, k - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>补一个完整的快排：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(self, arr, left, right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left &lt; right:</span><br><span class="line">            position = self.Partition(arr, left, right)</span><br><span class="line">            self.quicksort(arr, left, position<span class="number">-1</span>)</span><br><span class="line">            self.quicksort(arr, position+<span class="number">1</span>, right)</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    <span class="comment">#一个Point的方法，以left为轴心，以 pivot 为分界线将数组中其他元素分为两部分，使得左边部分的数小于等于枢轴，右边部分的数大于等于枢轴</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Partition</span><span class="params">(self, arr, left ,right)</span>:</span></span><br><span class="line">        index = left</span><br><span class="line">        pivot = arr[left]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(left+<span class="number">1</span>, right+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &lt; pivot:</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i != index:</span><br><span class="line">                    arr[i], arr[index] = arr[index], arr[i]</span><br><span class="line">        arr[index], arr[left] = arr[left], arr[index]</span><br><span class="line">        <span class="keyword">return</span> index</span><br><span class="line"></span><br><span class="line">    <span class="comment">#两个point的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Partition</span><span class="params">(self, arr, left ,right)</span>:</span></span><br><span class="line">        pivot = arr[left]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[right] &gt; pivot:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            arr[left] = arr[right]</span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[left] &lt;= pivot:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            arr[right] = arr[left]</span><br><span class="line">        arr[left] = pivot</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<p>Sweetiee-<a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/3chong-jie-fa-miao-sha-topkkuai-pai-dui-er-cha-sou/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/3chong-jie-fa-miao-sha-topkkuai-pai-dui-er-cha-sou/</a></p>
<p><a href="https://www.jianshu.com/p/4b7684b967e2" target="_blank" rel="noopener">python 快速排序+Partition()函数 Leetcode 75、215</a></p>
<hr>
<h4 id="6-Z-字形变换"><a href="#6-Z-字形变换" class="headerlink" title="6. Z 字形变换"></a><a href="https://leetcode-cn.com/problems/zigzag-conversion/" target="_blank" rel="noopener">6. Z 字形变换</a></h4><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为 <code>&quot;LEETCODEISHIRING&quot;</code> 行数为 3 时，排列如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure>
<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;LCIRETOESIIGEDHN&quot;</code>。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3</span><br><span class="line">输出: &quot;LCIRETOESIIGEDHN&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4</span><br><span class="line">输出: &quot;LDREOEIIECIHNTSG&quot;</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">L     D     R</span><br><span class="line">E   O E   I I</span><br><span class="line">E C   I H   N</span><br><span class="line">T     S     G</span><br></pre></td></tr></table></figure>
<p>简言之 数学不好天理不容==</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, s, numRows)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type numRows: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=<span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> numRows==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        step=<span class="number">2</span>*numRows<span class="number">-2</span></span><br><span class="line">        col=len(s)/step</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(s),step):</span><br><span class="line">                    res+=s[i] <span class="comment"># 第一行</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,numRows<span class="number">-1</span>):</span><br><span class="line">            j=i</span><br><span class="line">            <span class="keyword">while</span> j &lt;len(s):</span><br><span class="line">                res+=s[j]</span><br><span class="line">                j+=((numRows-i)*<span class="number">2</span><span class="number">-2</span>)</span><br><span class="line">                <span class="keyword">if</span> j&lt;len(s):</span><br><span class="line">                    res+=s[j]</span><br><span class="line">                    j+=<span class="number">2</span>*i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numRows<span class="number">-1</span>,len(s),step):<span class="comment"># 最后一行</span></span><br><span class="line">            res+=s[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>参考自评论-泠音清梦</p>
<hr>
<h4 id="365-水壶问题"><a href="#365-水壶问题" class="headerlink" title="365. 水壶问题"></a><a href="https://leetcode-cn.com/problems/water-and-jug-problem/" target="_blank" rel="noopener">365. 水壶问题</a></h4><p>有两个容量分别为 <em>x</em>升 和 <em>y</em>升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 <em>z</em>升 的水？</p>
<p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 <em>z升</em> 水。</p>
<p>你允许：</p>
<ul>
<li>装满任意一个水壶</li>
<li>清空任意一个水壶</li>
<li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li>
</ul>
<p><strong>示例 1:</strong> (From the famous <a href="https://www.youtube.com/watch?v=BVtQNK_ZUJg" target="_blank" rel="noopener"><em>“Die Hard”</em> example</a>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: x = 3, y = 5, z = 4</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: x = 2, y = 6, z = 5</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>
<h5 id="搜索遍历"><a href="#搜索遍历" class="headerlink" title="搜索遍历"></a>搜索遍历</h5><p>首先对题目进行建模。观察题目可知，在任意一个时刻，此问题的状态可以由两个数字决定：X 壶中的水量，以及 Y 壶中的水量。</p>
<p>在任意一个时刻，我们可以且仅可以采取以下几种操作：</p>
<ul>
<li>把 X 壶的水灌进 Y 壶，直至灌满或倒空；</li>
<li>把 Y 壶的水灌进 X 壶，直至灌满或倒空；</li>
<li>把 X 壶灌满；</li>
<li>把 Y 壶灌满；</li>
<li>把 X 壶倒空；</li>
<li>把 Y 壶倒空。</li>
</ul>
<p>因此，本题可以使用深度优先搜索来解决。搜索中的每一步以 <code>remain_x, remain_y</code> 作为状态，即表示 X 壶和 Y 壶中的水量。在每一步搜索时，我们会依次尝试所有的操作，递归地搜索下去。这可能会导致我们陷入无止境的递归，因此我们还需要使用一个哈希结合（HashSet）存储所有已经搜索过的 <code>remain_x, remain_y</code> 状态，保证每个状态至多只被搜索一次。</p>
<p>在实际的代码编写中，由于深度优先搜索导致的递归远远超过了 Python 的默认递归层数（可以使用 <code>sys</code> 库更改递归层数，但不推荐这么做），因此下面的代码使用栈来模拟递归，避免了真正使用递归而导致的问题。</p>
<p>说人话就是用一个stack记录每一次水量的状态；</p>
<p>stack append 每一次的状态 i 经过一次操作之后可能达到的所有状态</p>
<p>然后记录对这些状态再经过一次操作的所有状态</p>
<p>对出现过的状态进行跳过</p>
<p>seen记录已经出现过的状态</p>
<p>……</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#DFS：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canMeasureWater</span><span class="params">(self, x: int, y: int, z: int)</span> -&gt; bool:</span></span><br><span class="line">        stack = [(<span class="number">0</span>, <span class="number">0</span>)]</span><br><span class="line">        self.seen = set()</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            remain_x, remain_y = stack.pop()<span class="comment">#记录每次以remain_x和remain_y开始经过一步之后可以到达的所有状态，然后每次对上一次可以到达的所有状态进行遍历。。</span></span><br><span class="line">            <span class="keyword">if</span> remain_x == z <span class="keyword">or</span> remain_y == z <span class="keyword">or</span> remain_x + remain_y == z:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> (remain_x, remain_y) <span class="keyword">in</span> self.seen:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.seen.add((remain_x, remain_y)) <span class="comment"># 把当前状态加入seen</span></span><br><span class="line">            <span class="comment"># 把 X 壶灌满。</span></span><br><span class="line">            stack.append((x, remain_y))</span><br><span class="line">            <span class="comment"># 把 Y 壶灌满。</span></span><br><span class="line">            stack.append((remain_x, y))</span><br><span class="line">            <span class="comment"># 把 X 壶倒空。</span></span><br><span class="line">            stack.append((<span class="number">0</span>, remain_y))</span><br><span class="line">            <span class="comment"># 把 Y 壶倒空。</span></span><br><span class="line">            stack.append((remain_x, <span class="number">0</span>))</span><br><span class="line">            <span class="comment"># 把 X 壶的水灌进 Y 壶，直至灌满或倒空。</span></span><br><span class="line">            stack.append((remain_x - min(remain_x, y - remain_y), remain_y + min(remain_x, y - remain_y)))</span><br><span class="line">            <span class="comment"># 把 Y 壶的水灌进 X 壶，直至灌满或倒空。</span></span><br><span class="line">            stack.append((remain_x + min(remain_y, x - remain_x), remain_y - min(remain_y, x - remain_x)))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># BFS    </span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canMeasureWater</span><span class="params">(self, x: int, y: int, z: int)</span> -&gt; bool:</span>  </span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        queue = deque([[<span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line">        visited = set([(<span class="number">0</span>, <span class="number">0</span>)])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur_x, cur_y = queue.pop()</span><br><span class="line">            <span class="keyword">if</span> z <span class="keyword">in</span> [cur_x, cur_y, cur_x + cur_y]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> [</span><br><span class="line">                <span class="comment"># 加满水</span></span><br><span class="line">                (x, cur_y), (cur_x, y),</span><br><span class="line">                <span class="comment"># 清空水</span></span><br><span class="line">                (<span class="number">0</span>, cur_y), (cur_x, <span class="number">0</span>),</span><br><span class="line">                <span class="comment"># x -&gt; y</span></span><br><span class="line">                (cur_x + cur_y - y, y) <span class="keyword">if</span> cur_x + cur_y &gt;= y <span class="keyword">else</span> (<span class="number">0</span>, cur_x + cur_y),</span><br><span class="line">                <span class="comment"># y -&gt; x</span></span><br><span class="line">                (x, cur_x + cur_y - x) <span class="keyword">if</span> cur_x + cur_y &gt;= x <span class="keyword">else</span> (cur_x + cur_y, <span class="number">0</span>)]:</span><br><span class="line">                <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    queue.appendleft(item)</span><br><span class="line">                    visited.add(item)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h5 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h5><p>转换成数学公式就是 $ax+by=z$ 是否成立，a,b 为正数则不断地加x和不断地加y，a,b为负数，就可以不断地减去x和y</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canMeasureWater</span><span class="params">(self, x, y, z)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :type y: int</span></span><br><span class="line"><span class="string">        :type z: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 这个吧，又考数学，我不太会。=</span></span><br><span class="line">        <span class="comment"># 找到x,y的最大公约数能否z被整除</span></span><br><span class="line">        <span class="comment"># 最大公约数 的数学我又忘了=。</span></span><br><span class="line">        <span class="comment"># 辗转相除 最小公倍数等于 两数乘积/最大公约数</span></span><br><span class="line">        <span class="comment"># 最大公约数的递归：</span></span><br><span class="line">        <span class="comment"># * 1、若a可以整除b，则最大公约数是b</span></span><br><span class="line">        <span class="comment"># * 2、如果1不成立，最大公约数便是b与a%b的最大公约数</span></span><br><span class="line">        <span class="comment"># * 示例：求(140,21)</span></span><br><span class="line">        <span class="comment"># * 140%21 = 14</span></span><br><span class="line">        <span class="comment"># * 21%14 = 7</span></span><br><span class="line">        <span class="comment"># * 14%7 = 0</span></span><br><span class="line">        <span class="comment"># * 返回7</span></span><br><span class="line">        <span class="keyword">if</span> z == <span class="number">0</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> x+y &lt; z:<span class="comment">#需要的水大于两个容量</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> x&gt;y:  <span class="comment"># 确保y &gt; x</span></span><br><span class="line">            x,y=y,x</span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>: <span class="comment"># 当只有一个桶，或没有桶的时候</span></span><br><span class="line">            <span class="keyword">return</span> y==z </span><br><span class="line">        <span class="keyword">while</span> y%x != <span class="number">0</span>:<span class="comment">#辗转相除</span></span><br><span class="line">            y,x = x,y%x <span class="comment"># 余数为0时的x即为最大公约数</span></span><br><span class="line">        <span class="keyword">return</span> z%x==<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>参考：</p>
<p>官方题解<a href="https://leetcode-cn.com/problems/water-and-jug-problem/solution/shui-hu-wen-ti-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/water-and-jug-problem/solution/shui-hu-wen-ti-by-leetcode-solution/</a></p>
<p>评论区-TimeMac</p>
<hr>
<h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></h4><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>
<p>其实就是一个队列,比如例题中的 <code>abcabcbb</code>，进入这个队列（<strong>窗口</strong>）为 <code>abc</code> 满足题目要求，当再进入 <code>a</code>，队列变成了 <code>abca</code>，这时候不满足要求。所以，我们要移动这个队列！</p>
<p>如何移动？</p>
<p>我们只要把队列的左边的元素移出就行了，直到满足题目要求！</p>
<p>一直维持这样的队列，找出队列出现最长的长度时候，求出解！</p>
<p>时间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 滑动窗口</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        lookup = set()</span><br><span class="line">        n = len(s)</span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        cur_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            cur_len += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> s[i] <span class="keyword">in</span> lookup:<span class="comment"># 如果有重复的，就不断移除左边，直到没有重复的</span></span><br><span class="line">                lookup.remove(s[left])</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                cur_len -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur_len &gt; max_len:max_len = cur_len</span><br><span class="line">            lookup.add(s[i])</span><br><span class="line">        <span class="keyword">return</span> max_len</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 优化 的滑动窗口</span></span><br><span class="line">        st=&#123;&#125;<span class="comment"># 记录元素出现位置</span></span><br><span class="line">        i,ans=<span class="number">0</span>,<span class="number">0</span> <span class="comment"># i为记录里的子串的初始位置,ans为最长长度</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[j] <span class="keyword">in</span> st: <span class="comment"># 如果重复了</span></span><br><span class="line">                <span class="comment"># print(st[s[j]]+1,i)</span></span><br><span class="line">                i=max(st[s[j]]+<span class="number">1</span>,i)<span class="comment"># 更新子串开始的位置 # 注意要取两个的最大值</span></span><br><span class="line">                <span class="comment"># 所以当s[j]在st中时，其实有两种情况，第一种是重复在子串中，此时st[s[j]]+1是大于i的，就更新i为st[s[j]]+1值；另一种情况是其实重复的字符并不在当前的子串中，这时i是大于st[s[j]]+1的，保持i的大小不变即可</span></span><br><span class="line">                print(<span class="string">'i'</span>,i)</span><br><span class="line">                print(<span class="string">'s[j]'</span>,s[j])</span><br><span class="line">            ans=max(ans,j-i+<span class="number">1</span>) <span class="comment"># 更新最长的长度</span></span><br><span class="line">            st[s[j]] = j</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>题解：powcai-<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/hua-dong-chuang-kou-by-powcai/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/hua-dong-chuang-kou-by-powcai/</a></p>
<hr>
<h4 id="945-使数组唯一的最小增量"><a href="#945-使数组唯一的最小增量" class="headerlink" title="945. 使数组唯一的最小增量"></a><a href="https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/" target="_blank" rel="noopener">945. 使数组唯一的最小增量</a></h4><p>给定整数数组 A，每次 <em>move</em> 操作将会选择任意 <code>A[i]</code>，并将其递增 <code>1</code>。</p>
<p>返回使 <code>A</code> 中的每个值都是唯一的最少操作次数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：经过一次 move 操作，数组将变为 [1, 2, 3]。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,2,1,2,1,7]</span><br><span class="line">输出：6</span><br><span class="line">解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。</span><br><span class="line">可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= A.length &lt;= 40000</code></li>
<li><code>0 &lt;= A[i] &lt; 40000</code></li>
</ol>
<p>自己写了会超时。=</p>
<p>题解区sweetiee-<a href="https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/solution/ji-shu-onxian-xing-tan-ce-fa-onpai-xu-onlogn-yi-ya/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/solution/ji-shu-onxian-xing-tan-ce-fa-onpai-xu-onlogn-yi-ya/</a></p>
<p><strong>排序O(nlogn)</strong><br>逻辑：先排序，再依次遍历数组元素，若当前元素小于等于它前一个元素，则将其变为前一个数+1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minIncrementForUnique</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># way-1</span></span><br><span class="line">         A.sort()</span><br><span class="line">         move=<span class="number">0</span></span><br><span class="line">        <span class="comment"># // 遍历数组，若当前元素小于等于它的前一个元素，则将其变为前一个数+1</span></span><br><span class="line">         <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(A)):</span><br><span class="line">             <span class="keyword">if</span> (A[i] &lt;= A[i - <span class="number">1</span>]):</span><br><span class="line">                 pre = A[i]</span><br><span class="line">                 A[i] = A[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                 move += A[i] - pre</span><br><span class="line">         <span class="keyword">return</span> move</span><br></pre></td></tr></table></figure>
<p><strong>计数排序O(N)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minIncrementForUnique</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// counter数组统计每个数字的个数。</span></span><br><span class="line">        <span class="comment">//（这里为了防止下面遍历counter的时候每次都走到40000，所以设置了一个max，这个数据量不设也行，再额外设置min也行）</span></span><br><span class="line">        <span class="keyword">int</span>[] counter = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">40000</span>];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: A) &#123;<span class="comment">//统计每个数字的个数，没有出现的数字也在统计里面</span></span><br><span class="line">            counter[num]++;</span><br><span class="line">            max = Math.max(max, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历counter数组，若当前数字的个数cnt大于1个，则只留下1个，其他的cnt-1个后移1位，再使计数数组的下一位加cnt-1</span></span><br><span class="line">        <span class="keyword">int</span> move = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">0</span>; num &lt;= max; num++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (counter[num] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> d = counter[num] - <span class="number">1</span>;</span><br><span class="line">                move += d; </span><br><span class="line">                counter[num + <span class="number">1</span>] += d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后, counter[max+1]里可能会有从counter[max]后移过来的，counter[max+1]里只留下1个，其它的d个后移。</span></span><br><span class="line">        <span class="comment">// 设 max+1 = x，那么后面的d个数就是[x+1,x+2,x+3,...,x+d],</span></span><br><span class="line">        <span class="comment">// 因此操作次数是[1,2,3,...,d],用求和公式求和。</span></span><br><span class="line">        <span class="keyword">int</span> d = counter[max + <span class="number">1</span>] - <span class="number">1</span>;<span class="comment">//超出max长度的计数</span></span><br><span class="line">        move += (<span class="number">1</span> + d) * d / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> move;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>线性探测法O(N) （含路径压缩）</strong></p>
<ul>
<li>这道题换句话说，就是需要把原数组映射到一个地址不冲突的区域，映射后的地址不小于原数组对应的元素。<br>比如[3, 2, 1, 2, 1, 7]就映射成了[3, 2, 1, 4, 5, 7]。</li>
<li>这道题目其实和解决hash冲突的线性探测法比较相似，如果地址冲突了，会探测它的下一个位置，如果下一个位置还是冲突，继续向后看，直到第一个不冲突的位置为止。</li>
<li>关键点：因为直接线性探测可能会由于冲突导致反复探测耗时太长，因此我们可以考虑探测的过程中进行路径压缩。<ul>
<li>路径压缩：就是经过某条路径最终探测到一个空位置x后，将这条路径上的值都变成空位置所在的下标x，那么假如下次探测的点又是这条路径上的点，则可以直接跳转到这次探测到的空位置x，从x开始继续探测。</li>
<li>是的我就没有压缩路径，然后超时了</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>[] pos = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">80000</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minIncrementForUnique</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        Arrays.fill(pos, <span class="number">-1</span>); <span class="comment">// -1表示空位</span></span><br><span class="line">        <span class="keyword">int</span> move = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历每个数字a对其寻地址得到位置b, b比a的增量就是操作数。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a: A) &#123;</span><br><span class="line">            <span class="keyword">int</span> b = findPos(a); </span><br><span class="line">            move += b - a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> move;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线性探测寻址（含路径压缩）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findPos</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = pos[a];</span><br><span class="line">    <span class="comment">// 如果a对应的位置pos[a]是空位，直接放入即可。</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">-1</span>) &#123; </span><br><span class="line">        pos[a] = a;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则向后寻址</span></span><br><span class="line">    <span class="comment">// 因为pos[a]中标记了上次寻址得到的空位，因此从pos[a]+1开始寻址就行了（不需要从a+1开始）。</span></span><br><span class="line">    b = findPos(b + <span class="number">1</span>); </span><br><span class="line">    pos[a] = b; <span class="comment">// 寻址后的新空位要重新赋值给pos[a]哦，路径压缩就是体现在这里。下次再遇到可以从这一次定位的空位开始往后查找</span></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">876. 链表的中间结点</a></h4><p>给定一个带有头结点 <code>head</code> 的非空单链表，返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,5]</span><br><span class="line">输出：此列表中的结点 3 (序列化形式：[3,4,5])</span><br><span class="line">返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。</span><br><span class="line">注意，我们返回了一个 ListNode 类型的对象 ans，这样：</span><br><span class="line">ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,5,6]</span><br><span class="line">输出：此列表中的结点 4 (序列化形式：[4,5,6])</span><br><span class="line">由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleNode</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 双指针 相当于一个指针一次走两步，另一个指针一次走一步，那么当第一个指针走到尾的时候，第二个指针就在中间</span></span><br><span class="line">        fast=head</span><br><span class="line">        low=head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> fast.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            low=low.next</span><br><span class="line">            fast=fast.next.next</span><br><span class="line">        <span class="keyword">return</span> low </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 自己写的字典  空间复杂度有点高</span></span><br><span class="line">        dict=&#123;&#125;</span><br><span class="line">        tmp=head</span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> tmp <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            dict[i]=tmp</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            tmp=tmp.next</span><br><span class="line">        <span class="keyword">return</span> dict[len(dict)/<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>参考：评论区-金少辉</p>
<hr>
<h4 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a><a href="https://leetcode-cn.com/problems/multiply-strings/" target="_blank" rel="noopener">43. 字符串相乘</a></h4><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;</span><br><span class="line">输出: &quot;6&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;</span><br><span class="line">输出: &quot;56088&quot;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><code>num1</code> 和 <code>num2</code> 的长度小于110。</li>
<li><code>num1</code> 和 <code>num2</code> 只包含数字 <code>0-9</code>。</li>
<li><code>num1</code> 和 <code>num2</code> 均不以零开头，除非是数字 0 本身。</li>
<li><strong>不能使用任何标准库的大数类型（比如 BigInteger）</strong>或<strong>直接将输入转换为整数来处理</strong>。</li>
</ol>
<p><strong>普通乘法</strong></p>
<p>这个我写出来了，不过偷懒最后的字符串相加直接转int的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, num1, num2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type num1: str</span></span><br><span class="line"><span class="string">        :type num2: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 没有想到其他方法，就按照运算规则先写一下吧</span></span><br><span class="line">        cnt=[]</span><br><span class="line">        <span class="keyword">if</span> len(num1)&lt;len(num2):<span class="comment"># 保证num2更短或相等</span></span><br><span class="line">            num1,num2=num2,num1</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">mul</span><span class="params">(num1,num2)</span>:</span></span><br><span class="line">            strs=<span class="string">""</span></span><br><span class="line">            pos=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> num1[::<span class="number">-1</span>]:</span><br><span class="line">                tmp=int(i)*int(num2)+pos</span><br><span class="line">                <span class="comment"># print("tmp",tmp)</span></span><br><span class="line">                pos=tmp/<span class="number">10</span></span><br><span class="line">                strs+=str(tmp%<span class="number">10</span>)</span><br><span class="line">            <span class="comment"># print(strs[::-1])</span></span><br><span class="line">            <span class="keyword">if</span> pos!=<span class="number">0</span>:strs+=str(pos)</span><br><span class="line">            <span class="keyword">return</span> int(strs[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(num2)):</span><br><span class="line">            cnt.append((<span class="number">10</span>**i)*mul(num1,num2[<span class="number">-1</span>-i]))</span><br><span class="line">        <span class="keyword">return</span> str(sum(cnt))</span><br></pre></td></tr></table></figure>
<p><strong>优化的竖式乘法</strong></p>
<ul>
<li><p>虽然计算时间和空间复杂度跟普通乘法是一样的，但是运行起来会快很多</p>
</li>
<li><p>该算法通过两数相乘时，乘数某位与被乘数某位相乘，与产生结果的位置的规律来完成。具体规律如下：</p>
<ul>
<li><p>乘数 num1 位数为 M，被乘数 num2 位数为 N， <code>num1 x num2</code>结果 res 最大总位数为 M+N</p>
</li>
<li><p><code>num1[i] x num2[j]</code>的结果为 tmp(位数为两位，”0x”,”xy”的形式)，其第一位位于 <code>res[i+j]</code>，第二位位于 <code>res[i+j+1]</code>。</p>
</li>
</ul>
</li>
</ul>
<p><img src="/2020/02/22/leetcode/leetcode-笔记/竖式乘法.png" alt="竖式乘法" style="zoom: 33%;"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Javaclass Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[num1.length() + num2.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num1.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = num1.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = num2.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> n2 = num2.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">               <span class="comment">//重要是这三行 竖式乘法</span></span><br><span class="line">                <span class="keyword">int</span> sum = (res[i + j + <span class="number">1</span>] + n1 * n2);</span><br><span class="line">                res[i + j + <span class="number">1</span>] = sum % <span class="number">10</span>;</span><br><span class="line">                res[i + j] += sum / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; res[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            result.append(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：breezean-<a href="https://leetcode-cn.com/problems/multiply-strings/solution/you-hua-ban-shu-shi-da-bai-994-by-breezean/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/multiply-strings/solution/you-hua-ban-shu-shi-da-bai-994-by-breezean/</a></p>
<hr>
<h4 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><a href="https://leetcode-cn.com/problems/decode-ways/" target="_blank" rel="noopener">91. 解码方法</a></h4><p>一条包含字母 <code>A-Z</code> 的消息通过以下方式进行了编码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;A&apos; -&gt; 1</span><br><span class="line">&apos;B&apos; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&apos;Z&apos; -&gt; 26</span><br></pre></td></tr></table></figure>
<p>给定一个只包含数字的<strong>非空</strong>字符串，请计算解码方法的总数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;12&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;226&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。</span><br></pre></td></tr></table></figure>
<p>你怎么就不知道用动态规划了呢？</p>
<p>怎么把思路理清楚。。。。。。。很关键。。。</p>
<p>pris_bupt-<a href="https://leetcode-cn.com/problems/decode-ways/solution/c-wo-ren-wei-hen-jian-dan-zhi-guan-de-jie-fa-by-pr/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/decode-ways/solution/c-wo-ren-wei-hen-jian-dan-zhi-guan-de-jie-fa-by-pr/</a></p>
<p><img src="https://pic.leetcode-cn.com/c09dc70d3085792b2b8417843e297f6841fd12f921b0e4fe28a2c4a8dc86dd1e-image.png" alt="image.png"></p>
<p>改写python</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 我擦，你现在又不知道用dp 了？？？？</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>]==<span class="string">'0'</span>: <span class="comment"># 0不能单独编码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        pre=<span class="number">1</span> <span class="comment">#由于dp数组仅与前两项相关， 可以将空间复杂度缩减成变量形式</span></span><br><span class="line">        curr=<span class="number">1</span> <span class="comment"># 初始化值为1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(s)):<span class="comment"># 注意从1开始</span></span><br><span class="line">            tmp=curr</span><br><span class="line">            <span class="keyword">if</span> s[i]==<span class="string">'0'</span>:</span><br><span class="line">                <span class="keyword">if</span> s[i<span class="number">-1</span>]==<span class="string">'1'</span> <span class="keyword">or</span> s[i<span class="number">-1</span>]==<span class="string">'2'</span>:</span><br><span class="line">                    curr=pre</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> s[i<span class="number">-1</span>]==<span class="string">'1'</span> <span class="keyword">or</span> (s[i<span class="number">-1</span>]==<span class="string">'2'</span> <span class="keyword">and</span> <span class="string">'1'</span>&lt;=s[i]&lt;=<span class="string">'6'</span>):</span><br><span class="line">                curr=curr+pre</span><br><span class="line">            pre=tmp</span><br><span class="line">        <span class="keyword">return</span> curr</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10. 正则表达式匹配</a></h4><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;.&apos; 匹配任意单个字符</span><br><span class="line">&apos;*&apos; 匹配零个或多个前面的那一个元素</span><br></pre></td></tr></table></figure>
<p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code>的，而不是部分字符串。</p>
<p><strong>说明:</strong></p>
<ul>
<li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &apos;*&apos; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &apos;a&apos;。因此，字符串 &quot;aa&quot; 可被视为 &apos;a&apos; 重复了一次。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;ab&quot;</span><br><span class="line">p = &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&apos;*&apos;）任意字符（&apos;.&apos;）。</span><br></pre></td></tr></table></figure>
<p><strong>示例 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aab&quot;</span><br><span class="line">p = &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &apos;*&apos; 表示零个或多个，这里 &apos;c&apos; 为 0 个, &apos;a&apos; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure>
<p><strong>示例 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;mississippi&quot;</span><br><span class="line">p = &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p>labuladong–<a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type p: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 带备忘录的递归</span></span><br><span class="line">        memo = dict() <span class="comment"># 备忘录</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> (i, j) <span class="keyword">in</span> memo: <span class="keyword">return</span> memo[(i, j)]</span><br><span class="line">            <span class="keyword">if</span> j == len(p): <span class="keyword">return</span> i == len(s)</span><br><span class="line">            first = i &lt; len(s) <span class="keyword">and</span> p[j] <span class="keyword">in</span> &#123;s[i], <span class="string">'.'</span>&#125;</span><br><span class="line">            <span class="keyword">if</span> j &lt;= len(p) - <span class="number">2</span> <span class="keyword">and</span> p[j + <span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                ans = dp(i, j + <span class="number">2</span>) <span class="keyword">or</span> first <span class="keyword">and</span> dp(i + <span class="number">1</span>, j)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans = first <span class="keyword">and</span> dp(i + <span class="number">1</span>, j + <span class="number">1</span>)</span><br><span class="line">            memo[(i, j)] = ans</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 暴力递归</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> <span class="keyword">not</span> p: <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">         first = bool(s) <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">in</span> &#123;s[<span class="number">0</span>], <span class="string">'.'</span>&#125;</span><br><span class="line">         <span class="keyword">if</span> len(p) &gt;= <span class="number">2</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">             <span class="keyword">return</span> self.isMatch(s, p[<span class="number">2</span>:]) <span class="keyword">or</span> \</span><br><span class="line">                     first <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p)</span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">             <span class="keyword">return</span> first <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 自己写的对.*判断还是不完全的东西</span></span><br><span class="line">        <span class="comment"># i,j=0,0</span></span><br><span class="line">        <span class="comment"># flag=0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># while j &lt; len(p) and i &lt; len(s):</span></span><br><span class="line">        <span class="comment">#     if s[i]==p[j] or p[j]=='.':</span></span><br><span class="line">        <span class="comment">#         j+=1</span></span><br><span class="line">        <span class="comment">#         i+=1</span></span><br><span class="line">        <span class="comment">#         continue # 符合规则</span></span><br><span class="line">        <span class="comment">#     elif p[j]=='*':</span></span><br><span class="line">        <span class="comment">#         if p[j-1]=='.': # .*cd 后边如果不一样也不行</span></span><br><span class="line">        <span class="comment">#             j+=1</span></span><br><span class="line">        <span class="comment">#             while i &lt; len(s) and j &lt; len(p) and s[i]!=p[j]:</span></span><br><span class="line">        <span class="comment">#                 i+=1</span></span><br><span class="line">        <span class="comment">#             if i==len(s):</span></span><br><span class="line">        <span class="comment">#                 return False</span></span><br><span class="line">        <span class="comment">#             i+=1</span></span><br><span class="line">        <span class="comment">#             j+=1</span></span><br><span class="line">        <span class="comment">#             continue</span></span><br><span class="line">        <span class="comment">#         elif p[j-1]!=s[i-1]:</span></span><br><span class="line">        <span class="comment">#             j+=1</span></span><br><span class="line">        <span class="comment">#             continue</span></span><br><span class="line">        <span class="comment">#         while  i &lt; len(s) and s[i]==s[i-1]:</span></span><br><span class="line">        <span class="comment">#             i+=1</span></span><br><span class="line">        <span class="comment">#         j+=1</span></span><br><span class="line">        <span class="comment">#         continue</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         i+=1</span></span><br><span class="line">        <span class="comment">#         j+=1</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># print(i,j)</span></span><br><span class="line">        <span class="comment"># return False if i&lt;len(s) or j&lt;len(p) else True</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="65-有效数字"><a href="#65-有效数字" class="headerlink" title="65. 有效数字"></a><a href="https://leetcode-cn.com/problems/valid-number/" target="_blank" rel="noopener">65. 有效数字</a></h4><p>验证给定的字符串是否可以解释为十进制数字。</p>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&quot;0&quot;` =&gt; `true`</span><br><span class="line"> `&quot; 0.1 &quot;` =&gt; `true`</span><br><span class="line"> `&quot;abc&quot;` =&gt; `false`</span><br><span class="line"> `&quot;1 a&quot;` =&gt; `false`</span><br><span class="line"> `&quot;2e10&quot;` =&gt; `true`</span><br><span class="line"> `&quot; -90e3  &quot;` =&gt; `true`</span><br><span class="line"> `&quot; 1e&quot;` =&gt; `false`</span><br><span class="line"> `&quot;e3&quot;` =&gt; `false`</span><br><span class="line"> `&quot; 6e-1&quot;` =&gt; `true`</span><br><span class="line"> `&quot; 99e2.5 &quot;` =&gt; `false`</span><br><span class="line"> `&quot;53.5e93&quot;` =&gt; `true`</span><br><span class="line"> `&quot; --6 &quot;` =&gt; `false`</span><br><span class="line"> `&quot;-+3&quot;` =&gt; `false`</span><br><span class="line"> `&quot;95a54e53&quot;` =&gt; `false</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong> 我们有意将问题陈述地比较模糊。在实现代码之前，你应当事先思考所有可能的情况。这里给出一份可能存在于有效十进制数字中的字符列表：</p>
<ul>
<li>数字 0-9</li>
<li>指数 - “e”</li>
<li>正/负号 - “+”/“-“</li>
<li>小数点 - “.”</li>
</ul>
<p>当然，在输入中，这些字符的上下文也很重要。</p>
<p>参考：</p>
<p>powcai-<a href="https://leetcode-cn.com/problems/valid-number/solution/fan-ti-by-powcai/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-number/solution/fan-ti-by-powcai/</a></p>
<p>评论区代码等</p>
<p>状态机：</p>
<p><img src="https://pic.leetcode-cn.com/0ae239f74ce6ecaaf7c9044291b3fcdc8c5e60ac28dc447b7712a1500f9b3e01-1.png" alt="1.png"></p>
<ul>
<li>isdigit()<ul>
<li>True: Unicode数字，byte数字（单字节），全角数字（双字节），罗马数字</li>
<li>False: 汉字数字</li>
<li>Error: 无</li>
</ul>
</li>
<li>isdecimal()<ul>
<li>True: Unicode数字，，全角数字（双字节）</li>
<li>False: 罗马数字，汉字数字</li>
<li>Error: byte数字（单字节）</li>
</ul>
</li>
<li>isnumeric()<ul>
<li>True: Unicode数字，全角数字（双字节），罗马数字，汉字数字</li>
<li>False: 无</li>
<li>Error: byte数字（单字节）</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把e前后拆开来考虑： 题解评论区的代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># way1 可以用状态机，把总共的所有状态列举出来</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># way2 对e进行截断之后分别对两边的合法性进行验证的情况</span></span><br><span class="line">        s = s.strip()  <span class="comment"># 去掉两端的空白符</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s :</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> s[<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">'+'</span>, <span class="string">'-'</span>]:</span><br><span class="line">                s = s[<span class="number">1</span>:]  <span class="comment"># 去掉正负号</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">'e'</span> <span class="keyword">in</span> s:</span><br><span class="line">                temp_list = s.split(<span class="string">'e'</span>)</span><br><span class="line">                <span class="keyword">if</span> len(temp_list) &gt; <span class="number">2</span>:  <span class="comment"># 字符串s中含有多于一个的’e‘,返回False</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                temp_list[<span class="number">0</span>] = temp_list[<span class="number">0</span>].replace(<span class="string">'.'</span>, <span class="string">''</span>, <span class="number">1</span>)  <span class="comment"># 去掉e前面的字符串中的'.'</span></span><br><span class="line">                <span class="keyword">if</span> len(temp_list[<span class="number">1</span>]) &gt; <span class="number">0</span> <span class="keyword">and</span> temp_list[<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">'+'</span>, <span class="string">'-'</span>]:  <span class="comment"># 去掉e后面字符串中的'+'或者'-'</span></span><br><span class="line">                    temp_list[<span class="number">1</span>] = temp_list[<span class="number">1</span>].replace(temp_list[<span class="number">1</span>][<span class="number">0</span>], <span class="string">''</span>, <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> temp_list[<span class="number">0</span>].isnumeric() <span class="keyword">and</span> temp_list[<span class="number">1</span>].isnumeric():</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># s中不含'e'</span></span><br><span class="line">                s = s.replace(<span class="string">'.'</span>, <span class="string">''</span>, <span class="number">1</span>) <span class="comment"># 只能有1个.</span></span><br><span class="line">                <span class="keyword">if</span> s.isnumeric():</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 考虑所有情况</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s: str)</span>:</span></span><br><span class="line">        s = s.strip()</span><br><span class="line">        <span class="comment">#print(s)</span></span><br><span class="line">        dot_seen = <span class="keyword">False</span> <span class="comment"># 记录每一次的状态</span></span><br><span class="line">        e_seen = <span class="keyword">False</span></span><br><span class="line">        num_seen = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> i, a <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> a.isdigit():</span><br><span class="line">                num_seen = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> a == <span class="string">"."</span>:</span><br><span class="line">                <span class="keyword">if</span> e_seen <span class="keyword">or</span> dot_seen:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                dot_seen = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> a == <span class="string">"e"</span>:</span><br><span class="line">                <span class="keyword">if</span> e_seen <span class="keyword">or</span> <span class="keyword">not</span> num_seen:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                num_seen = <span class="keyword">False</span></span><br><span class="line">                e_seen = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> a <span class="keyword">in</span> <span class="string">"+-"</span>:</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> s[i - <span class="number">1</span>] != <span class="string">"e"</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> num_seen</span><br><span class="line"></span><br><span class="line"><span class="comment"># 状态机</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        state = [</span><br><span class="line">            &#123;&#125;,</span><br><span class="line">            <span class="comment"># 状态1,初始状态(扫描通过的空格)</span></span><br><span class="line">            &#123;<span class="string">"blank"</span>: <span class="number">1</span>, <span class="string">"sign"</span>: <span class="number">2</span>, <span class="string">"digit"</span>: <span class="number">3</span>, <span class="string">"."</span>: <span class="number">4</span>&#125;,</span><br><span class="line">            <span class="comment"># 状态2,发现符号位(后面跟数字或者小数点)</span></span><br><span class="line">            &#123;<span class="string">"digit"</span>: <span class="number">3</span>, <span class="string">"."</span>: <span class="number">4</span>&#125;,</span><br><span class="line">            <span class="comment"># 状态3,数字(一直循环到非数字)</span></span><br><span class="line">            &#123;<span class="string">"digit"</span>: <span class="number">3</span>, <span class="string">"."</span>: <span class="number">5</span>, <span class="string">"e"</span>: <span class="number">6</span>, <span class="string">"blank"</span>: <span class="number">9</span>&#125;,</span><br><span class="line">            <span class="comment"># 状态4,小数点(后面只有紧接数字)</span></span><br><span class="line">            &#123;<span class="string">"digit"</span>: <span class="number">5</span>&#125;,</span><br><span class="line">            <span class="comment"># 状态5,小数点之后(后面只能为数字,e,或者以空格结束)</span></span><br><span class="line">            &#123;<span class="string">"digit"</span>: <span class="number">5</span>, <span class="string">"e"</span>: <span class="number">6</span>, <span class="string">"blank"</span>: <span class="number">9</span>&#125;,</span><br><span class="line">            <span class="comment"># 状态6,发现e(后面只能符号位, 和数字)</span></span><br><span class="line">            &#123;<span class="string">"sign"</span>: <span class="number">7</span>, <span class="string">"digit"</span>: <span class="number">8</span>&#125;,</span><br><span class="line">            <span class="comment"># 状态7,e之后(只能为数字)</span></span><br><span class="line">            &#123;<span class="string">"digit"</span>: <span class="number">8</span>&#125;,</span><br><span class="line">            <span class="comment"># 状态8,e之后的数字后面(只能为数字或者以空格结束)</span></span><br><span class="line">            &#123;<span class="string">"digit"</span>: <span class="number">8</span>, <span class="string">"blank"</span>: <span class="number">9</span>&#125;,</span><br><span class="line">            <span class="comment"># 状态9, 终止状态 (如果发现非空,就失败)</span></span><br><span class="line">            &#123;<span class="string">"blank"</span>: <span class="number">9</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">        cur_state = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c.isdigit():</span><br><span class="line">                c = <span class="string">"digit"</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">" "</span>:</span><br><span class="line">                c = <span class="string">"blank"</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">"+-"</span>:</span><br><span class="line">                c = <span class="string">"sign"</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> state[cur_state]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            cur_state = state[cur_state][c]</span><br><span class="line">        <span class="keyword">if</span> cur_state <span class="keyword">not</span> <span class="keyword">in</span> [<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<hr>
<p>同学的笔试题及相应解法：</p>
<p>返回-1的情况：只要是字符出现次数不同或者是字符不同都是-1（是用排序做的）</p>
<p>对每次移动到最后的处理：</p>
<ul>
<li>只要对应顺序相同，就可以不用移动，而需要移动的字符顺序根据移动的先后顺序而定，因此不用考虑</li>
<li>采用双指针，以t字符串为基准，不相同的就cnt+1，只需对s遍历一遍即可</li>
</ul>
<p>经过len(s)次移动应该可以得到所有的字符串</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="comment">// 输入： 字符串 s , t (1 &lt;= |s| = |t| &lt; 1e5 范围不太记得了)</span></span><br><span class="line"><span class="comment">// 输出： 计算字符串 s 变成 t 的最小代价； 若无法完成则返回 -1</span></span><br><span class="line"><span class="comment">// 条件： 允许将 s 中的任一字符移动至最后，代价为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例</span></span><br><span class="line"><span class="comment">// 输入： s = "ckad", t = "ackd"</span></span><br><span class="line"><span class="comment">// 输出： 3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s, t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="comment">// 处理可能匹配不成功的情况，当时只想到排序。。</span></span><br><span class="line">    <span class="built_in">string</span> ss = s, tt = t;</span><br><span class="line">    sort(ss.begin(), ss.end());</span><br><span class="line">    sort(tt.begin(), tt.end());</span><br><span class="line">    <span class="keyword">if</span>(ss != tt) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;        <span class="comment">//返回值，因为移动没有规定顺序，只需要计算移动的字符数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; len <span class="keyword">and</span> j &lt; len; ++ i, ++ j) &#123;</span><br><span class="line">        <span class="comment">// 从 s 中找和 t[j] 匹配的字符，不匹配的一定会移到尾部</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; len <span class="keyword">and</span> s[i] != t[j]) &#123;</span><br><span class="line">            ++ ret;</span><br><span class="line">            ++ i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同学的笔试题2（同学真是个大佬）</p>
<ul>
<li>考虑每次选择最小值与不选择最小值的概率，通过p_left记录在之前的区间里没有选到最小值的概率，再与后面的区间中取到最小值的概率相乘</li>
<li>通过将每次计算过后的区间左边界++，来避免取到比当前最小值更小的值</li>
<li>真是奇妙。。。。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入： 数字 n （有 n 个区域）</span></span><br><span class="line"><span class="comment">//       n个数字，代表左边界</span></span><br><span class="line"><span class="comment">//       n个数字，代表右边界</span></span><br><span class="line"><span class="comment">// 输出： n 个区域中，任一取 n 个数字（区间内的数字被选到的概率是相同的），求 n 个数字最小值的期望</span></span><br><span class="line"><span class="comment">// 例</span></span><br><span class="line"><span class="comment">// 输入： 2</span></span><br><span class="line"><span class="comment">//       1 3</span></span><br><span class="line"><span class="comment">//       2 3</span></span><br><span class="line"><span class="comment">// 输出： 1.833333(允许1e-6的精度误差)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小值为1时，两个随机数有(1,2),(1,3)两种情况，概率为2/6.</span></span><br><span class="line"><span class="comment">// 最小值为2时，两个随机数有(2,2),(2,3),(3,2)两种情况，概率为3/6.</span></span><br><span class="line"><span class="comment">// 最小值为3时，两个随机数有(3,3)两种情况，概率为1/6.</span></span><br><span class="line"><span class="comment">// 最小值的期望为1* 2/6+2* 3/6+3* 1/6=1.83333333</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortRange</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; range)</span> </span>&#123;</span><br><span class="line">    sort(range.begin(), range.end(), [](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.first == b.first)</span><br><span class="line">            <span class="comment">// 将范围较小的区域排在前面， 我也不知道为什么。。</span></span><br><span class="line">            <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">        <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; range;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; range[i].first;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; range[i].second;</span><br><span class="line">    <span class="keyword">double</span> ret = <span class="number">0</span>;             <span class="comment">// 返回值</span></span><br><span class="line">    <span class="keyword">double</span> p_left = <span class="number">1</span>, p = <span class="number">0</span>;   <span class="comment">// p_left：未分配的概率， p：本次选到这个值的概率</span></span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    sortRange(range);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p_left &gt; <span class="number">0</span> <span class="keyword">and</span> range[idx].first &lt;= range[idx].second ) &#123;</span><br><span class="line">        <span class="comment">// 计算当前最小值可能被选择到的概率 p * 当前未分配的概率 p_left</span></span><br><span class="line">        p = range[idx].second - range[idx].first+<span class="number">1</span>; <span class="comment">// 选最小的概率</span></span><br><span class="line">        p = <span class="number">1</span> / p * p_left;  </span><br><span class="line">        ret += range[idx].first * p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新当前未分配的概率 p_left ——之前不选最小的概率</span></span><br><span class="line">        p_left -= p;</span><br><span class="line"></span><br><span class="line">        ++ range[idx].first;</span><br><span class="line">        <span class="keyword">if</span>(idx &lt; n <span class="keyword">and</span> range[idx + <span class="number">1</span>].first  &gt;= range[idx].first) &#123;</span><br><span class="line">            <span class="comment">// 如果当前最小值已经计算完成，需要重新排序，计算下一个数字充当最小值的概率</span></span><br><span class="line">            sortRange(range);</span><br><span class="line">            idx = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 继续计算当前最小值在后续区域被选到的概率</span></span><br><span class="line">             ++ idx;</span><br><span class="line">             <span class="keyword">if</span>(idx == n)</span><br><span class="line">                idx = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a></h4><p>给你两个单词 <em>word1</em> 和 <em>word2</em>，请你计算出将 <em>word1</em> 转换成 <em>word2</em> 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ol>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ol>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &apos;h&apos; 替换为 &apos;r&apos;)</span><br><span class="line">rorse -&gt; rose (删除 &apos;r&apos;)</span><br><span class="line">rose -&gt; ros (删除 &apos;e&apos;)</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 &apos;t&apos;)</span><br><span class="line">inention -&gt; enention (将 &apos;i&apos; 替换为 &apos;e&apos;)</span><br><span class="line">enention -&gt; exention (将 &apos;n&apos; 替换为 &apos;x&apos;)</span><br><span class="line">exention -&gt; exection (将 &apos;n&apos; 替换为 &apos;c&apos;)</span><br><span class="line">exection -&gt; execution (插入 &apos;u&apos;)</span><br></pre></td></tr></table></figure>
<p>powcai–<a href="https://leetcode-cn.com/problems/edit-distance/solution/zi-di-xiang-shang-he-zi-ding-xiang-xia-by-powcai-3/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/edit-distance/solution/zi-di-xiang-shang-he-zi-ding-xiang-xia-by-powcai-3/</a></p>
<p>labuladong–<a href="https://leetcode-cn.com/problems/edit-distance/solution/bian-ji-ju-chi-mian-shi-ti-xiang-jie-by-labuladong/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/edit-distance/solution/bian-ji-ju-chi-mian-shi-ti-xiang-jie-by-labuladong/</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1, word2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type word1: str</span></span><br><span class="line"><span class="string">        :type word2: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#dp题</span></span><br><span class="line">        <span class="comment"># 找清楚状态和转移情况</span></span><br><span class="line">        <span class="comment"># dp可以分为自顶向下和自底向上，自顶向下往往是递归的做法，而自底向上往往是通过dp表</span></span><br><span class="line">        <span class="comment"># 自底向上：dp表的方法</span></span><br><span class="line">        <span class="comment"># xrange与range类似，只是返回的是一个"xrange object"对象，而非数组list。</span></span><br><span class="line">        <span class="comment"># 要生成很大的数字序列的时候，用xrange会比range性能优很多，因为不需要一上来就开辟一块很大的内存空间。</span></span><br><span class="line">        n1 = len(word1)</span><br><span class="line">        n2 = len(word2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n2 + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n1 + <span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 第一行</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n2 + <span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 第一列</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n1 + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n1 + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = min(dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j<span class="number">-1</span>] ) + <span class="number">1</span></span><br><span class="line">        <span class="comment">#print(dp)      </span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 自顶向下</span></span><br><span class="line">        <span class="comment">#通过索引号而不是切片(O(n))</span></span><br><span class="line">        <span class="comment"># 会有重复子问题</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="comment"># base case # 有个词被遍历完了</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">-1</span>: <span class="keyword">return</span> j + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">-1</span>: <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> s1[i] == s2[j]:</span><br><span class="line">                <span class="keyword">return</span> dp(i - <span class="number">1</span>, j - <span class="number">1</span>)  <span class="comment"># 啥都不做</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> min(</span><br><span class="line">                    dp(i, j - <span class="number">1</span>) + <span class="number">1</span>,    <span class="comment"># 插入</span></span><br><span class="line">                    dp(i - <span class="number">1</span>, j) + <span class="number">1</span>,    <span class="comment"># 删除</span></span><br><span class="line">                    dp(i - <span class="number">1</span>, j - <span class="number">1</span>) + <span class="number">1</span> <span class="comment"># 替换</span></span><br><span class="line">                )</span><br><span class="line">        <span class="comment"># i，j 初始化指向最后一个索引</span></span><br><span class="line">        <span class="keyword">return</span> dp(len(s1) - <span class="number">1</span>, len(s2) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 带memo的递归</span></span><br><span class="line">        memo = dict() <span class="comment"># 备忘录</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> (i, j) <span class="keyword">in</span> memo: </span><br><span class="line">                <span class="keyword">return</span> memo[(i, j)]</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">-1</span>: <span class="keyword">return</span> j + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">-1</span>: <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> s1[i] == s2[j]:</span><br><span class="line">                memo[(i, j)] = memo[(i<span class="number">-1</span>,j<span class="number">-1</span>)] </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                memo[(i, j)] = min(memo[(i<span class="number">-1</span>,j<span class="number">-1</span>)],memo[(i<span class="number">-1</span>,j)],memo[(i,j<span class="number">-1</span>)])+<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> memo[(i, j)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp(len(s1) - <span class="number">1</span>, len(s2) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 记录路径的遍历</span></span><br><span class="line">        Node[][] dp;</span><br><span class="line">        class Node &#123;</span><br><span class="line">            int val;</span><br><span class="line">            int choice;</span><br><span class="line">            <span class="comment"># // 0 代表啥都不做</span></span><br><span class="line">            <span class="comment"># // 1 代表插入</span></span><br><span class="line">            <span class="comment"># // 2 代表删除</span></span><br><span class="line">            <span class="comment"># // 3 代表替换</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="面试题-08-11-硬币"><a href="#面试题-08-11-硬币" class="headerlink" title="面试题 08.11. 硬币"></a><a href="https://leetcode-cn.com/problems/coin-lcci/" target="_blank" rel="noopener">面试题 08.11. 硬币</a></h4><p>硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p>
<p> <strong>示例1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 输入: n = 5</span><br><span class="line"> 输出：2</span><br><span class="line"> 解释: 有两种方式可以凑成总金额:</span><br><span class="line">5=5</span><br><span class="line">5=1+1+1+1+1</span><br></pre></td></tr></table></figure>
<p> <strong>示例2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 输入: n = 10</span><br><span class="line"> 输出：4</span><br><span class="line"> 解释: 有四种方式可以凑成总金额:</span><br><span class="line">10=10</span><br><span class="line">10=5+5</span><br><span class="line">10=5+1+1+1+1+1</span><br><span class="line">10=1+1+1+1+1+1+1+1+1+1</span><br></pre></td></tr></table></figure>
<p>听说是个完全背包问题，还没有整理，题目可以简单整理成多元一次方程解的个数，用二维dp可以直接做</p>
<ul>
<li><code>dp[i][j]</code>表示从开始到第i个未知数时，和为j 的方法数，但由于在硬币数组添加了0项，对数组的index有些变化</li>
<li>状态转移方程：<ul>
<li>第一种情况当前coin[i]的值大于j，那么一定取不到第i个硬币，所以其方法数与<code>dp[i-1][j]</code>相同，即不取该硬币时，总和达到j的方法数</li>
<li>第二种情况是当前coin[i]的值小于或等于j，那么就有可能会取到第i个硬币，其方法数为<code>dp[i-1][j]+dp[i][j-coin[i]]</code>，即不取第i个硬币的方法数（前i-1个硬币总和j的方法数）+ 取该硬币的方法数（取了该硬币i后，剩下的i-1个硬币总和为j-coin[i]的方法数。</li>
</ul>
</li>
<li>最后考虑边界就好了：<ul>
<li>第0列即所有硬币总和为0的方法数均为1，即所有硬币都不取</li>
<li>由于涉及到dp[i-1]及上一行的数据，故添加第0行，使得除了<code>dp[0][0]</code>位置为1，其余为0（对0个硬币不取即为0，故方法数1，其余均为0），然后从第一行开始对每个硬币开始计算即可</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">waysToChange</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 从前天的网易面试过来的</span></span><br><span class="line">        <span class="comment"># # 看懂了二维dp的做法，先试一下</span></span><br><span class="line">        coin=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>]<span class="comment">#前边补0，补充第0行，方便后边统一计算</span></span><br><span class="line">        dp=[[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(n+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(coin))]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(coin)):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span> <span class="comment"># 初始化第一列置为1,第一行除了第一个值，其他默认为0即可</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">if</span> coin[i]&lt;=n:<span class="comment">#可以取到这个coin</span></span><br><span class="line">                    dp[i][j]+=dp[i][j-coin[i]]</span><br><span class="line">        <span class="keyword">return</span> dp[len(coin)<span class="number">-1</span>][n]%<span class="number">1000000007</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 再试一下一维数组</span></span><br><span class="line">        <span class="comment"># 从上面的状态转移方程可以看出，dp[i][j]只与dp[i-1][j]和dp[i][j-coins[i]]有关，所以完全可以把第一个维度除掉，只用一个一维数组存储</span></span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        coins = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(coin, n+<span class="number">1</span>):<span class="comment"># 每一层进行覆盖和叠加就可以了</span></span><br><span class="line">                dp[i] += dp[i-coin]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>] % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>
<p>参考：</p>
<p>yuanninesuns-<a href="https://leetcode-cn.com/problems/coin-lcci/solution/dong-tai-gui-hua-jian-dan-yi-dong-by-yuanninesuns/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/coin-lcci/solution/dong-tai-gui-hua-jian-dan-yi-dong-by-yuanninesuns/</a></p>
<p>YesOhh-<a href="https://leetcode-cn.com/problems/coin-lcci/solution/python3-yi-er-wei-dp-he-ji-yi-hua-sou-suo-by-yesoh/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/coin-lcci/solution/python3-yi-er-wei-dp-he-ji-yi-hua-sou-suo-by-yesoh/</a></p>

      
    </div>

    

    
    
    

    

    

    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------　　　　本文结束　<i class="fa fa-heart"></i>　感谢您的阅读　　　　-------------</div>
    
</div>
      
    </div>

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/02/07/学习/book/统计学习方法/统计学习方法绪论及第一章笔记/" rel="next" title="统计学习方法绪论及第一章笔记">
                <i class="fa fa-chevron-left"></i> 统计学习方法绪论及第一章笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/12/论文/A-Review-of-Relation-Extraction/" rel="prev" title="A_Review_of_Relation_Extraction">
                A_Review_of_Relation_Extraction <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/headimg/14.jpg"
                alt="Lavi" />
            
              <p class="site-author-name" itemprop="name">Lavi</p>
              <p class="site-description motion-element" itemprop="description">进化ing</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">66</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/zlovey" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:937198813@qq.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#寻找两个有序数组的中位数"><span class="nav-number">1.</span> <span class="nav-text">寻找两个有序数组的中位数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺失的第一个正数难度"><span class="nav-number">2.</span> <span class="nav-text">缺失的第一个正数难度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#57-插入区间"><span class="nav-number">3.</span> <span class="nav-text">57. 插入区间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#84-柱状图中最大的矩形"><span class="nav-number">4.</span> <span class="nav-text">84. 柱状图中最大的矩形</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#123-买卖股票的最佳时机-III"><span class="nav-number">5.</span> <span class="nav-text">123. 买卖股票的最佳时机 III</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态规划"><span class="nav-number">6.</span> <span class="nav-text">动态规划</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#状态机"><span class="nav-number">7.</span> <span class="nav-text">状态机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#126-单词接龙-II"><span class="nav-number">8.</span> <span class="nav-text">126. 单词接龙 II</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#DFS深度优先遍历"><span class="nav-number">8.1.</span> <span class="nav-text">DFS深度优先遍历</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#345-反转字符串中的元音字母"><span class="nav-number">9.</span> <span class="nav-text">345. 反转字符串中的元音字母</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-有效的括号"><span class="nav-number">10.</span> <span class="nav-text">20. 有效的括号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#125-验证回文串"><span class="nav-number">11.</span> <span class="nav-text">125. 验证回文串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#67-二进制求和"><span class="nav-number">12.</span> <span class="nav-text">67. 二进制求和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#58-最后一个单词的长度"><span class="nav-number">13.</span> <span class="nav-text">58. 最后一个单词的长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-最长公共前缀"><span class="nav-number">14.</span> <span class="nav-text">14. 最长公共前缀</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#165-比较版本号"><span class="nav-number">15.</span> <span class="nav-text">165. 比较版本号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1160-拼写单词"><span class="nav-number">16.</span> <span class="nav-text">1160. 拼写单词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#71-简化路径"><span class="nav-number">17.</span> <span class="nav-text">71. 简化路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#409-最长回文串"><span class="nav-number">18.</span> <span class="nav-text">409. 最长回文串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-最长回文子串"><span class="nav-number">19.</span> <span class="nav-text">5. 最长回文子串</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#暴力匹配-时间-O-N-3-空间-O-1"><span class="nav-number">19.1.</span> <span class="nav-text">暴力匹配   时间$O(N^3)$ 空间$O(1)$</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#动态规划-时间-O-N-2-空间-O-N-2-：本质是用空间换取时间"><span class="nav-number">19.2.</span> <span class="nav-text">动态规划     时间 $O(N^2)$ 空间  $O(N^2)$  ：本质是用空间换取时间</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#第-1-步：定义状态"><span class="nav-number">19.2.1.</span> <span class="nav-text">第 1 步：定义状态</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#第-2-步：思考状态转移方程"><span class="nav-number">19.2.2.</span> <span class="nav-text">第 2 步：思考状态转移方程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#第-3-步：考虑初始化"><span class="nav-number">19.2.3.</span> <span class="nav-text">第 3 步：考虑初始化</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#第-4-步：考虑输出"><span class="nav-number">19.2.4.</span> <span class="nav-text">第 4 步：考虑输出</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#第-5-步：考虑状态是否可以压缩"><span class="nav-number">19.2.5.</span> <span class="nav-text">第 5 步：考虑状态是否可以压缩</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#中心扩散法-时间-O-N-2-空间-O-1"><span class="nav-number">19.3.</span> <span class="nav-text">中心扩散法   时间 $O(N^2)$ 空间  $O(1)$</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Manacher-算法时间-O-N-空间-O-N"><span class="nav-number">19.4.</span> <span class="nav-text">Manacher 算法时间 $O(N)$ 空间  $O(N)$  </span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#第-1-步：对原始字符串进行预处理（添加分隔符）"><span class="nav-number">19.4.1.</span> <span class="nav-text">第 1 步：对原始字符串进行预处理（添加分隔符）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#第-2-步：计算辅助数组-p"><span class="nav-number">19.4.2.</span> <span class="nav-text">第 2 步：计算辅助数组 p</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#结论：辅助数组-p-的最大值就是“最长回文子串”的长度。"><span class="nav-number">19.4.3.</span> <span class="nav-text">结论：辅助数组 p 的最大值就是“最长回文子串”的长度。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#改进"><span class="nav-number">19.4.4.</span> <span class="nav-text">改进</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#面试题40-最小的k个数"><span class="nav-number">20.</span> <span class="nav-text">面试题40. 最小的k个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-Z-字形变换"><span class="nav-number">21.</span> <span class="nav-text">6. Z 字形变换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#365-水壶问题"><span class="nav-number">22.</span> <span class="nav-text">365. 水壶问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#搜索遍历"><span class="nav-number">22.1.</span> <span class="nav-text">搜索遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数学方法"><span class="nav-number">22.2.</span> <span class="nav-text">数学方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-无重复字符的最长子串"><span class="nav-number">23.</span> <span class="nav-text">3. 无重复字符的最长子串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#945-使数组唯一的最小增量"><span class="nav-number">24.</span> <span class="nav-text">945. 使数组唯一的最小增量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#876-链表的中间结点"><span class="nav-number">25.</span> <span class="nav-text">876. 链表的中间结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#43-字符串相乘"><span class="nav-number">26.</span> <span class="nav-text">43. 字符串相乘</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#91-解码方法"><span class="nav-number">27.</span> <span class="nav-text">91. 解码方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-正则表达式匹配"><span class="nav-number">28.</span> <span class="nav-text">10. 正则表达式匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#65-有效数字"><span class="nav-number">29.</span> <span class="nav-text">65. 有效数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#72-编辑距离"><span class="nav-number">30.</span> <span class="nav-text">72. 编辑距离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#面试题-08-11-硬币"><span class="nav-number">31.</span> <span class="nav-text">面试题 08.11. 硬币</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lavi</span>

  

  
</div>


<!--

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Gemini</a> v6.3.0</div>



-->
        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  










  





  

  

  

  
  

  
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  


  
  

  

  

  

  

  

  
  <script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":true,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":70,"height":140},"mobile":{"show":true},"log":false});</script>
</body>
</html>
